// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: client/pps/pps.proto

/*
	Package pps is a generated protocol buffer package.

	It is generated from these files:
		client/pps/pps.proto

	It has these top-level messages:
		Secret
		Transform
		Egress
		Job
		Service
		AtomInput
		CronInput
		GitInput
		Input
		JobInput
		ParallelismSpec
		InputFile
		Datum
		DatumInfo
		Aggregate
		ProcessStats
		AggregateProcessStats
		WorkerStatus
		ResourceSpec
		EtcdJobInfo
		JobInfo
		Worker
		JobInfos
		Pipeline
		PipelineInput
		EtcdPipelineInfo
		PipelineInfo
		PipelineInfos
		CreateJobRequest
		InspectJobRequest
		ListJobRequest
		FlushJobRequest
		DeleteJobRequest
		StopJobRequest
		GetLogsRequest
		LogMessage
		RestartDatumRequest
		InspectDatumRequest
		ListDatumRequest
		ListDatumResponse
		ListDatumStreamResponse
		ChunkSpec
		CreatePipelineRequest
		InspectPipelineRequest
		ListPipelineRequest
		DeletePipelineRequest
		StartPipelineRequest
		StopPipelineRequest
		RerunPipelineRequest
		GarbageCollectRequest
		GarbageCollectResponse
		ActivateAuthRequest
		ActivateAuthResponse
*/
package pps

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/types"
import google_protobuf1 "github.com/gogo/protobuf/types"
import google_protobuf2 "github.com/gogo/protobuf/types"
import _ "github.com/gogo/protobuf/gogoproto"
import pfs "github.com/pachyderm/pachyderm/src/client/pfs"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type JobState int32

const (
	JobState_JOB_STARTING JobState = 0
	JobState_JOB_RUNNING  JobState = 1
	JobState_JOB_FAILURE  JobState = 2
	JobState_JOB_SUCCESS  JobState = 3
	JobState_JOB_KILLED   JobState = 4
)

var JobState_name = map[int32]string{
	0: "JOB_STARTING",
	1: "JOB_RUNNING",
	2: "JOB_FAILURE",
	3: "JOB_SUCCESS",
	4: "JOB_KILLED",
}
var JobState_value = map[string]int32{
	"JOB_STARTING": 0,
	"JOB_RUNNING":  1,
	"JOB_FAILURE":  2,
	"JOB_SUCCESS":  3,
	"JOB_KILLED":   4,
}

func (x JobState) String() string {
	return proto.EnumName(JobState_name, int32(x))
}
func (JobState) EnumDescriptor() ([]byte, []int) { return fileDescriptorPps, []int{0} }

type DatumState int32

const (
	DatumState_FAILED   DatumState = 0
	DatumState_SUCCESS  DatumState = 1
	DatumState_SKIPPED  DatumState = 2
	DatumState_STARTING DatumState = 3
)

var DatumState_name = map[int32]string{
	0: "FAILED",
	1: "SUCCESS",
	2: "SKIPPED",
	3: "STARTING",
}
var DatumState_value = map[string]int32{
	"FAILED":   0,
	"SUCCESS":  1,
	"SKIPPED":  2,
	"STARTING": 3,
}

func (x DatumState) String() string {
	return proto.EnumName(DatumState_name, int32(x))
}
func (DatumState) EnumDescriptor() ([]byte, []int) { return fileDescriptorPps, []int{1} }

type WorkerState int32

const (
	WorkerState_POD_RUNNING WorkerState = 0
	WorkerState_POD_SUCCESS WorkerState = 1
	WorkerState_POD_FAILED  WorkerState = 2
)

var WorkerState_name = map[int32]string{
	0: "POD_RUNNING",
	1: "POD_SUCCESS",
	2: "POD_FAILED",
}
var WorkerState_value = map[string]int32{
	"POD_RUNNING": 0,
	"POD_SUCCESS": 1,
	"POD_FAILED":  2,
}

func (x WorkerState) String() string {
	return proto.EnumName(WorkerState_name, int32(x))
}
func (WorkerState) EnumDescriptor() ([]byte, []int) { return fileDescriptorPps, []int{2} }

type PipelineState int32

const (
	// When the pipeline is not ready to be triggered by commits.
	// This happens when either 1) a pipeline has been created but not
	// yet picked up by a PPS server, or 2) the pipeline does not have
	// any inputs and is meant to be triggered manually
	PipelineState_PIPELINE_STARTING PipelineState = 0
	// After this pipeline is picked up by a pachd node.  This is the normal
	// state of a pipeline.
	PipelineState_PIPELINE_RUNNING PipelineState = 1
	// After some error caused runPipeline to exit, but before the
	// pipeline is re-run.  This is when the exponential backoff is
	// in effect.
	PipelineState_PIPELINE_RESTARTING PipelineState = 2
	// We have retried too many times and we have given up on this pipeline.
	PipelineState_PIPELINE_FAILURE PipelineState = 3
	// The pipeline has been explicitly paused by the user.
	PipelineState_PIPELINE_PAUSED PipelineState = 4
)

var PipelineState_name = map[int32]string{
	0: "PIPELINE_STARTING",
	1: "PIPELINE_RUNNING",
	2: "PIPELINE_RESTARTING",
	3: "PIPELINE_FAILURE",
	4: "PIPELINE_PAUSED",
}
var PipelineState_value = map[string]int32{
	"PIPELINE_STARTING":   0,
	"PIPELINE_RUNNING":    1,
	"PIPELINE_RESTARTING": 2,
	"PIPELINE_FAILURE":    3,
	"PIPELINE_PAUSED":     4,
}

func (x PipelineState) String() string {
	return proto.EnumName(PipelineState_name, int32(x))
}
func (PipelineState) EnumDescriptor() ([]byte, []int) { return fileDescriptorPps, []int{3} }

type Secret struct {
	// Name must be the name of the secret in kubernetes.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Key of the secret to load into env_var, this field only has meaning if EnvVar != "".
	Key       string `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty"`
	MountPath string `protobuf:"bytes,2,opt,name=mount_path,json=mountPath,proto3" json:"mount_path,omitempty"`
	EnvVar    string `protobuf:"bytes,3,opt,name=env_var,json=envVar,proto3" json:"env_var,omitempty"`
}

func (m *Secret) Reset()                    { *m = Secret{} }
func (m *Secret) String() string            { return proto.CompactTextString(m) }
func (*Secret) ProtoMessage()               {}
func (*Secret) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{0} }

func (m *Secret) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Secret) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Secret) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *Secret) GetEnvVar() string {
	if m != nil {
		return m.EnvVar
	}
	return ""
}

type Transform struct {
	Image            string            `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	Cmd              []string          `protobuf:"bytes,2,rep,name=cmd" json:"cmd,omitempty"`
	Env              map[string]string `protobuf:"bytes,3,rep,name=env" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Secrets          []*Secret         `protobuf:"bytes,4,rep,name=secrets" json:"secrets,omitempty"`
	ImagePullSecrets []string          `protobuf:"bytes,9,rep,name=image_pull_secrets,json=imagePullSecrets" json:"image_pull_secrets,omitempty"`
	Stdin            []string          `protobuf:"bytes,5,rep,name=stdin" json:"stdin,omitempty"`
	AcceptReturnCode []int64           `protobuf:"varint,6,rep,packed,name=accept_return_code,json=acceptReturnCode" json:"accept_return_code,omitempty"`
	Debug            bool              `protobuf:"varint,7,opt,name=debug,proto3" json:"debug,omitempty"`
}

func (m *Transform) Reset()                    { *m = Transform{} }
func (m *Transform) String() string            { return proto.CompactTextString(m) }
func (*Transform) ProtoMessage()               {}
func (*Transform) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{1} }

func (m *Transform) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Transform) GetCmd() []string {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *Transform) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Transform) GetSecrets() []*Secret {
	if m != nil {
		return m.Secrets
	}
	return nil
}

func (m *Transform) GetImagePullSecrets() []string {
	if m != nil {
		return m.ImagePullSecrets
	}
	return nil
}

func (m *Transform) GetStdin() []string {
	if m != nil {
		return m.Stdin
	}
	return nil
}

func (m *Transform) GetAcceptReturnCode() []int64 {
	if m != nil {
		return m.AcceptReturnCode
	}
	return nil
}

func (m *Transform) GetDebug() bool {
	if m != nil {
		return m.Debug
	}
	return false
}

type Egress struct {
	URL string `protobuf:"bytes,1,opt,name=URL,proto3" json:"URL,omitempty"`
}

func (m *Egress) Reset()                    { *m = Egress{} }
func (m *Egress) String() string            { return proto.CompactTextString(m) }
func (*Egress) ProtoMessage()               {}
func (*Egress) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{2} }

func (m *Egress) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

type Job struct {
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Job) Reset()                    { *m = Job{} }
func (m *Job) String() string            { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()               {}
func (*Job) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{3} }

func (m *Job) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type Service struct {
	InternalPort int32  `protobuf:"varint,1,opt,name=internal_port,json=internalPort,proto3" json:"internal_port,omitempty"`
	ExternalPort int32  `protobuf:"varint,2,opt,name=external_port,json=externalPort,proto3" json:"external_port,omitempty"`
	IP           string `protobuf:"bytes,3,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *Service) Reset()                    { *m = Service{} }
func (m *Service) String() string            { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()               {}
func (*Service) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{4} }

func (m *Service) GetInternalPort() int32 {
	if m != nil {
		return m.InternalPort
	}
	return 0
}

func (m *Service) GetExternalPort() int32 {
	if m != nil {
		return m.ExternalPort
	}
	return 0
}

func (m *Service) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

type AtomInput struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Repo   string `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty"`
	Branch string `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	Commit string `protobuf:"bytes,4,opt,name=commit,proto3" json:"commit,omitempty"`
	Glob   string `protobuf:"bytes,5,opt,name=glob,proto3" json:"glob,omitempty"`
	Lazy   bool   `protobuf:"varint,6,opt,name=lazy,proto3" json:"lazy,omitempty"`
	// EmptyFiles, if true, will cause files from this atom to be presented as
	// empty files. This is useful in shuffle pipelines where you want to read
	// the names of files and reorganize them using symlinks.
	EmptyFiles bool `protobuf:"varint,8,opt,name=empty_files,json=emptyFiles,proto3" json:"empty_files,omitempty"`
}

func (m *AtomInput) Reset()                    { *m = AtomInput{} }
func (m *AtomInput) String() string            { return proto.CompactTextString(m) }
func (*AtomInput) ProtoMessage()               {}
func (*AtomInput) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{5} }

func (m *AtomInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AtomInput) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *AtomInput) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *AtomInput) GetCommit() string {
	if m != nil {
		return m.Commit
	}
	return ""
}

func (m *AtomInput) GetGlob() string {
	if m != nil {
		return m.Glob
	}
	return ""
}

func (m *AtomInput) GetLazy() bool {
	if m != nil {
		return m.Lazy
	}
	return false
}

func (m *AtomInput) GetEmptyFiles() bool {
	if m != nil {
		return m.EmptyFiles
	}
	return false
}

type CronInput struct {
	Name   string                      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Repo   string                      `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty"`
	Commit string                      `protobuf:"bytes,3,opt,name=commit,proto3" json:"commit,omitempty"`
	Spec   string                      `protobuf:"bytes,4,opt,name=spec,proto3" json:"spec,omitempty"`
	Start  *google_protobuf1.Timestamp `protobuf:"bytes,5,opt,name=start" json:"start,omitempty"`
}

func (m *CronInput) Reset()                    { *m = CronInput{} }
func (m *CronInput) String() string            { return proto.CompactTextString(m) }
func (*CronInput) ProtoMessage()               {}
func (*CronInput) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{6} }

func (m *CronInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CronInput) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *CronInput) GetCommit() string {
	if m != nil {
		return m.Commit
	}
	return ""
}

func (m *CronInput) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

func (m *CronInput) GetStart() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

type GitInput struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	URL    string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	Branch string `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	Commit string `protobuf:"bytes,4,opt,name=commit,proto3" json:"commit,omitempty"`
}

func (m *GitInput) Reset()                    { *m = GitInput{} }
func (m *GitInput) String() string            { return proto.CompactTextString(m) }
func (*GitInput) ProtoMessage()               {}
func (*GitInput) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{7} }

func (m *GitInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GitInput) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *GitInput) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *GitInput) GetCommit() string {
	if m != nil {
		return m.Commit
	}
	return ""
}

type Input struct {
	Atom  *AtomInput `protobuf:"bytes,1,opt,name=atom" json:"atom,omitempty"`
	Cross []*Input   `protobuf:"bytes,2,rep,name=cross" json:"cross,omitempty"`
	Union []*Input   `protobuf:"bytes,3,rep,name=union" json:"union,omitempty"`
	Cron  *CronInput `protobuf:"bytes,4,opt,name=cron" json:"cron,omitempty"`
	Git   *GitInput  `protobuf:"bytes,5,opt,name=git" json:"git,omitempty"`
}

func (m *Input) Reset()                    { *m = Input{} }
func (m *Input) String() string            { return proto.CompactTextString(m) }
func (*Input) ProtoMessage()               {}
func (*Input) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{8} }

func (m *Input) GetAtom() *AtomInput {
	if m != nil {
		return m.Atom
	}
	return nil
}

func (m *Input) GetCross() []*Input {
	if m != nil {
		return m.Cross
	}
	return nil
}

func (m *Input) GetUnion() []*Input {
	if m != nil {
		return m.Union
	}
	return nil
}

func (m *Input) GetCron() *CronInput {
	if m != nil {
		return m.Cron
	}
	return nil
}

func (m *Input) GetGit() *GitInput {
	if m != nil {
		return m.Git
	}
	return nil
}

type JobInput struct {
	Name   string      `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Commit *pfs.Commit `protobuf:"bytes,1,opt,name=commit" json:"commit,omitempty"`
	Glob   string      `protobuf:"bytes,2,opt,name=glob,proto3" json:"glob,omitempty"`
	Lazy   bool        `protobuf:"varint,3,opt,name=lazy,proto3" json:"lazy,omitempty"`
}

func (m *JobInput) Reset()                    { *m = JobInput{} }
func (m *JobInput) String() string            { return proto.CompactTextString(m) }
func (*JobInput) ProtoMessage()               {}
func (*JobInput) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{9} }

func (m *JobInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *JobInput) GetCommit() *pfs.Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *JobInput) GetGlob() string {
	if m != nil {
		return m.Glob
	}
	return ""
}

func (m *JobInput) GetLazy() bool {
	if m != nil {
		return m.Lazy
	}
	return false
}

type ParallelismSpec struct {
	// Starts the pipeline/job with a 'constant' workers, unless 'constant' is
	// zero. If 'constant' is zero (which is the zero value of ParallelismSpec),
	// then Pachyderm will choose the number of workers that is started,
	// (currently it chooses the number of workers in the cluster)
	Constant uint64 `protobuf:"varint,2,opt,name=constant,proto3" json:"constant,omitempty"`
	// Starts the pipeline/job with number of workers equal to 'coefficient' * N,
	// where N is the number of nodes in the kubernetes cluster.
	//
	// For example, if each Kubernetes node has four CPUs, you might set
	// 'coefficient' to four, so that there are four Pachyderm workers per
	// Kubernetes node, and each Pachyderm worker gets one CPU. If you want to
	// reserve half the nodes in your cluster for other tasks, you might set
	// 'coefficient' to 0.5.
	Coefficient float64 `protobuf:"fixed64,3,opt,name=coefficient,proto3" json:"coefficient,omitempty"`
}

func (m *ParallelismSpec) Reset()                    { *m = ParallelismSpec{} }
func (m *ParallelismSpec) String() string            { return proto.CompactTextString(m) }
func (*ParallelismSpec) ProtoMessage()               {}
func (*ParallelismSpec) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{10} }

func (m *ParallelismSpec) GetConstant() uint64 {
	if m != nil {
		return m.Constant
	}
	return 0
}

func (m *ParallelismSpec) GetCoefficient() float64 {
	if m != nil {
		return m.Coefficient
	}
	return 0
}

type InputFile struct {
	// This file's absolute path within its pfs repo.
	Path string `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
	// This file's hash
	Hash []byte `protobuf:"bytes,5,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *InputFile) Reset()                    { *m = InputFile{} }
func (m *InputFile) String() string            { return proto.CompactTextString(m) }
func (*InputFile) ProtoMessage()               {}
func (*InputFile) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{11} }

func (m *InputFile) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *InputFile) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type Datum struct {
	// ID is the hash computed from all the files
	ID  string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Job *Job   `protobuf:"bytes,2,opt,name=job" json:"job,omitempty"`
}

func (m *Datum) Reset()                    { *m = Datum{} }
func (m *Datum) String() string            { return proto.CompactTextString(m) }
func (*Datum) ProtoMessage()               {}
func (*Datum) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{12} }

func (m *Datum) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Datum) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type DatumInfo struct {
	Datum    *Datum          `protobuf:"bytes,1,opt,name=datum" json:"datum,omitempty"`
	State    DatumState      `protobuf:"varint,2,opt,name=state,proto3,enum=pps.DatumState" json:"state,omitempty"`
	Stats    *ProcessStats   `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
	PfsState *pfs.File       `protobuf:"bytes,4,opt,name=pfs_state,json=pfsState" json:"pfs_state,omitempty"`
	Data     []*pfs.FileInfo `protobuf:"bytes,5,rep,name=data" json:"data,omitempty"`
}

func (m *DatumInfo) Reset()                    { *m = DatumInfo{} }
func (m *DatumInfo) String() string            { return proto.CompactTextString(m) }
func (*DatumInfo) ProtoMessage()               {}
func (*DatumInfo) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{13} }

func (m *DatumInfo) GetDatum() *Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

func (m *DatumInfo) GetState() DatumState {
	if m != nil {
		return m.State
	}
	return DatumState_FAILED
}

func (m *DatumInfo) GetStats() *ProcessStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *DatumInfo) GetPfsState() *pfs.File {
	if m != nil {
		return m.PfsState
	}
	return nil
}

func (m *DatumInfo) GetData() []*pfs.FileInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type Aggregate struct {
	Count                 int64   `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	Mean                  float64 `protobuf:"fixed64,2,opt,name=mean,proto3" json:"mean,omitempty"`
	Stddev                float64 `protobuf:"fixed64,3,opt,name=stddev,proto3" json:"stddev,omitempty"`
	FifthPercentile       float64 `protobuf:"fixed64,4,opt,name=fifth_percentile,json=fifthPercentile,proto3" json:"fifth_percentile,omitempty"`
	NinetyFifthPercentile float64 `protobuf:"fixed64,5,opt,name=ninety_fifth_percentile,json=ninetyFifthPercentile,proto3" json:"ninety_fifth_percentile,omitempty"`
}

func (m *Aggregate) Reset()                    { *m = Aggregate{} }
func (m *Aggregate) String() string            { return proto.CompactTextString(m) }
func (*Aggregate) ProtoMessage()               {}
func (*Aggregate) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{14} }

func (m *Aggregate) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Aggregate) GetMean() float64 {
	if m != nil {
		return m.Mean
	}
	return 0
}

func (m *Aggregate) GetStddev() float64 {
	if m != nil {
		return m.Stddev
	}
	return 0
}

func (m *Aggregate) GetFifthPercentile() float64 {
	if m != nil {
		return m.FifthPercentile
	}
	return 0
}

func (m *Aggregate) GetNinetyFifthPercentile() float64 {
	if m != nil {
		return m.NinetyFifthPercentile
	}
	return 0
}

type ProcessStats struct {
	DownloadTime  *google_protobuf2.Duration `protobuf:"bytes,1,opt,name=download_time,json=downloadTime" json:"download_time,omitempty"`
	ProcessTime   *google_protobuf2.Duration `protobuf:"bytes,2,opt,name=process_time,json=processTime" json:"process_time,omitempty"`
	UploadTime    *google_protobuf2.Duration `protobuf:"bytes,3,opt,name=upload_time,json=uploadTime" json:"upload_time,omitempty"`
	DownloadBytes uint64                     `protobuf:"varint,4,opt,name=download_bytes,json=downloadBytes,proto3" json:"download_bytes,omitempty"`
	UploadBytes   uint64                     `protobuf:"varint,5,opt,name=upload_bytes,json=uploadBytes,proto3" json:"upload_bytes,omitempty"`
}

func (m *ProcessStats) Reset()                    { *m = ProcessStats{} }
func (m *ProcessStats) String() string            { return proto.CompactTextString(m) }
func (*ProcessStats) ProtoMessage()               {}
func (*ProcessStats) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{15} }

func (m *ProcessStats) GetDownloadTime() *google_protobuf2.Duration {
	if m != nil {
		return m.DownloadTime
	}
	return nil
}

func (m *ProcessStats) GetProcessTime() *google_protobuf2.Duration {
	if m != nil {
		return m.ProcessTime
	}
	return nil
}

func (m *ProcessStats) GetUploadTime() *google_protobuf2.Duration {
	if m != nil {
		return m.UploadTime
	}
	return nil
}

func (m *ProcessStats) GetDownloadBytes() uint64 {
	if m != nil {
		return m.DownloadBytes
	}
	return 0
}

func (m *ProcessStats) GetUploadBytes() uint64 {
	if m != nil {
		return m.UploadBytes
	}
	return 0
}

type AggregateProcessStats struct {
	DownloadTime  *Aggregate `protobuf:"bytes,1,opt,name=download_time,json=downloadTime" json:"download_time,omitempty"`
	ProcessTime   *Aggregate `protobuf:"bytes,2,opt,name=process_time,json=processTime" json:"process_time,omitempty"`
	UploadTime    *Aggregate `protobuf:"bytes,3,opt,name=upload_time,json=uploadTime" json:"upload_time,omitempty"`
	DownloadBytes *Aggregate `protobuf:"bytes,4,opt,name=download_bytes,json=downloadBytes" json:"download_bytes,omitempty"`
	UploadBytes   *Aggregate `protobuf:"bytes,5,opt,name=upload_bytes,json=uploadBytes" json:"upload_bytes,omitempty"`
}

func (m *AggregateProcessStats) Reset()                    { *m = AggregateProcessStats{} }
func (m *AggregateProcessStats) String() string            { return proto.CompactTextString(m) }
func (*AggregateProcessStats) ProtoMessage()               {}
func (*AggregateProcessStats) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{16} }

func (m *AggregateProcessStats) GetDownloadTime() *Aggregate {
	if m != nil {
		return m.DownloadTime
	}
	return nil
}

func (m *AggregateProcessStats) GetProcessTime() *Aggregate {
	if m != nil {
		return m.ProcessTime
	}
	return nil
}

func (m *AggregateProcessStats) GetUploadTime() *Aggregate {
	if m != nil {
		return m.UploadTime
	}
	return nil
}

func (m *AggregateProcessStats) GetDownloadBytes() *Aggregate {
	if m != nil {
		return m.DownloadBytes
	}
	return nil
}

func (m *AggregateProcessStats) GetUploadBytes() *Aggregate {
	if m != nil {
		return m.UploadBytes
	}
	return nil
}

type WorkerStatus struct {
	WorkerID string       `protobuf:"bytes,1,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty"`
	JobID    string       `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	Data     []*InputFile `protobuf:"bytes,3,rep,name=data" json:"data,omitempty"`
	// Started is the time processing on the current datum began.
	Started   *google_protobuf1.Timestamp `protobuf:"bytes,4,opt,name=started" json:"started,omitempty"`
	Stats     *ProcessStats               `protobuf:"bytes,5,opt,name=stats" json:"stats,omitempty"`
	QueueSize int64                       `protobuf:"varint,6,opt,name=queue_size,json=queueSize,proto3" json:"queue_size,omitempty"`
}

func (m *WorkerStatus) Reset()                    { *m = WorkerStatus{} }
func (m *WorkerStatus) String() string            { return proto.CompactTextString(m) }
func (*WorkerStatus) ProtoMessage()               {}
func (*WorkerStatus) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{17} }

func (m *WorkerStatus) GetWorkerID() string {
	if m != nil {
		return m.WorkerID
	}
	return ""
}

func (m *WorkerStatus) GetJobID() string {
	if m != nil {
		return m.JobID
	}
	return ""
}

func (m *WorkerStatus) GetData() []*InputFile {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *WorkerStatus) GetStarted() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *WorkerStatus) GetStats() *ProcessStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *WorkerStatus) GetQueueSize() int64 {
	if m != nil {
		return m.QueueSize
	}
	return 0
}

// ResourceSpec describes the amount of resources that pipeline pods should
// request from kubernetes, for scheduling.
type ResourceSpec struct {
	// The number of CPUs each worker needs (partial values are allowed, and
	// encouraged)
	Cpu float32 `protobuf:"fixed32,1,opt,name=cpu,proto3" json:"cpu,omitempty"`
	// The amount of memory, in bytes, each worker needs (in bytes, with allowed
	// SI suffixes (M, K, G, Mi, Ki, Gi, etc).
	Memory string `protobuf:"bytes,2,opt,name=memory,proto3" json:"memory,omitempty"`
	// The number of GPUs each worker needs.
	Gpu int64 `protobuf:"varint,3,opt,name=gpu,proto3" json:"gpu,omitempty"`
}

func (m *ResourceSpec) Reset()                    { *m = ResourceSpec{} }
func (m *ResourceSpec) String() string            { return proto.CompactTextString(m) }
func (*ResourceSpec) ProtoMessage()               {}
func (*ResourceSpec) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{18} }

func (m *ResourceSpec) GetCpu() float32 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *ResourceSpec) GetMemory() string {
	if m != nil {
		return m.Memory
	}
	return ""
}

func (m *ResourceSpec) GetGpu() int64 {
	if m != nil {
		return m.Gpu
	}
	return 0
}

// EtcdJobInfo is the portion of the JobInfo that gets stored in etcd during
// job execution. It contains fields which change over the lifetime of the job
// but aren't used in the execution of the job.
type EtcdJobInfo struct {
	Job          *Job        `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
	Pipeline     *Pipeline   `protobuf:"bytes,2,opt,name=pipeline" json:"pipeline,omitempty"`
	OutputCommit *pfs.Commit `protobuf:"bytes,3,opt,name=output_commit,json=outputCommit" json:"output_commit,omitempty"`
	// Job restart count (e.g. due to datum failure)
	Restart uint64 `protobuf:"varint,4,opt,name=restart,proto3" json:"restart,omitempty"`
	// Counts of how many times we processed or skipped a datum
	DataProcessed int64 `protobuf:"varint,5,opt,name=data_processed,json=dataProcessed,proto3" json:"data_processed,omitempty"`
	DataSkipped   int64 `protobuf:"varint,6,opt,name=data_skipped,json=dataSkipped,proto3" json:"data_skipped,omitempty"`
	DataTotal     int64 `protobuf:"varint,7,opt,name=data_total,json=dataTotal,proto3" json:"data_total,omitempty"`
	DataFailed    int64 `protobuf:"varint,8,opt,name=data_failed,json=dataFailed,proto3" json:"data_failed,omitempty"`
	// Download/process/upload time and download/upload bytes
	Stats       *ProcessStats `protobuf:"bytes,9,opt,name=stats" json:"stats,omitempty"`
	StatsCommit *pfs.Commit   `protobuf:"bytes,10,opt,name=stats_commit,json=statsCommit" json:"stats_commit,omitempty"`
	State       JobState      `protobuf:"varint,11,opt,name=state,proto3,enum=pps.JobState" json:"state,omitempty"`
	Reason      string        `protobuf:"bytes,12,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EtcdJobInfo) Reset()                    { *m = EtcdJobInfo{} }
func (m *EtcdJobInfo) String() string            { return proto.CompactTextString(m) }
func (*EtcdJobInfo) ProtoMessage()               {}
func (*EtcdJobInfo) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{19} }

func (m *EtcdJobInfo) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *EtcdJobInfo) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *EtcdJobInfo) GetOutputCommit() *pfs.Commit {
	if m != nil {
		return m.OutputCommit
	}
	return nil
}

func (m *EtcdJobInfo) GetRestart() uint64 {
	if m != nil {
		return m.Restart
	}
	return 0
}

func (m *EtcdJobInfo) GetDataProcessed() int64 {
	if m != nil {
		return m.DataProcessed
	}
	return 0
}

func (m *EtcdJobInfo) GetDataSkipped() int64 {
	if m != nil {
		return m.DataSkipped
	}
	return 0
}

func (m *EtcdJobInfo) GetDataTotal() int64 {
	if m != nil {
		return m.DataTotal
	}
	return 0
}

func (m *EtcdJobInfo) GetDataFailed() int64 {
	if m != nil {
		return m.DataFailed
	}
	return 0
}

func (m *EtcdJobInfo) GetStats() *ProcessStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *EtcdJobInfo) GetStatsCommit() *pfs.Commit {
	if m != nil {
		return m.StatsCommit
	}
	return nil
}

func (m *EtcdJobInfo) GetState() JobState {
	if m != nil {
		return m.State
	}
	return JobState_JOB_STARTING
}

func (m *EtcdJobInfo) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type JobInfo struct {
	Job              *Job                        `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
	Transform        *Transform                  `protobuf:"bytes,2,opt,name=transform" json:"transform,omitempty"`
	Pipeline         *Pipeline                   `protobuf:"bytes,3,opt,name=pipeline" json:"pipeline,omitempty"`
	PipelineVersion  uint64                      `protobuf:"varint,13,opt,name=pipeline_version,json=pipelineVersion,proto3" json:"pipeline_version,omitempty"`
	ParallelismSpec  *ParallelismSpec            `protobuf:"bytes,12,opt,name=parallelism_spec,json=parallelismSpec" json:"parallelism_spec,omitempty"`
	Egress           *Egress                     `protobuf:"bytes,15,opt,name=egress" json:"egress,omitempty"`
	ParentJob        *Job                        `protobuf:"bytes,6,opt,name=parent_job,json=parentJob" json:"parent_job,omitempty"`
	Started          *google_protobuf1.Timestamp `protobuf:"bytes,7,opt,name=started" json:"started,omitempty"`
	Finished         *google_protobuf1.Timestamp `protobuf:"bytes,8,opt,name=finished" json:"finished,omitempty"`
	OutputCommit     *pfs.Commit                 `protobuf:"bytes,9,opt,name=output_commit,json=outputCommit" json:"output_commit,omitempty"`
	State            JobState                    `protobuf:"varint,10,opt,name=state,proto3,enum=pps.JobState" json:"state,omitempty"`
	Reason           string                      `protobuf:"bytes,35,opt,name=reason,proto3" json:"reason,omitempty"`
	Service          *Service                    `protobuf:"bytes,14,opt,name=service" json:"service,omitempty"`
	OutputRepo       *pfs.Repo                   `protobuf:"bytes,18,opt,name=output_repo,json=outputRepo" json:"output_repo,omitempty"`
	OutputBranch     string                      `protobuf:"bytes,17,opt,name=output_branch,json=outputBranch,proto3" json:"output_branch,omitempty"`
	Restart          uint64                      `protobuf:"varint,20,opt,name=restart,proto3" json:"restart,omitempty"`
	DataProcessed    int64                       `protobuf:"varint,22,opt,name=data_processed,json=dataProcessed,proto3" json:"data_processed,omitempty"`
	DataSkipped      int64                       `protobuf:"varint,30,opt,name=data_skipped,json=dataSkipped,proto3" json:"data_skipped,omitempty"`
	DataFailed       int64                       `protobuf:"varint,40,opt,name=data_failed,json=dataFailed,proto3" json:"data_failed,omitempty"`
	DataTotal        int64                       `protobuf:"varint,23,opt,name=data_total,json=dataTotal,proto3" json:"data_total,omitempty"`
	Stats            *ProcessStats               `protobuf:"bytes,31,opt,name=stats" json:"stats,omitempty"`
	WorkerStatus     []*WorkerStatus             `protobuf:"bytes,24,rep,name=worker_status,json=workerStatus" json:"worker_status,omitempty"`
	ResourceRequests *ResourceSpec               `protobuf:"bytes,25,opt,name=resource_requests,json=resourceRequests" json:"resource_requests,omitempty"`
	ResourceLimits   *ResourceSpec               `protobuf:"bytes,36,opt,name=resource_limits,json=resourceLimits" json:"resource_limits,omitempty"`
	Input            *Input                      `protobuf:"bytes,26,opt,name=input" json:"input,omitempty"`
	NewBranch        *pfs.BranchInfo             `protobuf:"bytes,27,opt,name=new_branch,json=newBranch" json:"new_branch,omitempty"`
	Incremental      bool                        `protobuf:"varint,28,opt,name=incremental,proto3" json:"incremental,omitempty"`
	StatsCommit      *pfs.Commit                 `protobuf:"bytes,29,opt,name=stats_commit,json=statsCommit" json:"stats_commit,omitempty"`
	EnableStats      bool                        `protobuf:"varint,32,opt,name=enable_stats,json=enableStats,proto3" json:"enable_stats,omitempty"`
	Salt             string                      `protobuf:"bytes,33,opt,name=salt,proto3" json:"salt,omitempty"`
	Batch            bool                        `protobuf:"varint,34,opt,name=batch,proto3" json:"batch,omitempty"`
	ChunkSpec        *ChunkSpec                  `protobuf:"bytes,37,opt,name=chunk_spec,json=chunkSpec" json:"chunk_spec,omitempty"`
	DatumTimeout     *google_protobuf2.Duration  `protobuf:"bytes,38,opt,name=datum_timeout,json=datumTimeout" json:"datum_timeout,omitempty"`
	JobTimeout       *google_protobuf2.Duration  `protobuf:"bytes,39,opt,name=job_timeout,json=jobTimeout" json:"job_timeout,omitempty"`
}

func (m *JobInfo) Reset()                    { *m = JobInfo{} }
func (m *JobInfo) String() string            { return proto.CompactTextString(m) }
func (*JobInfo) ProtoMessage()               {}
func (*JobInfo) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{20} }

func (m *JobInfo) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *JobInfo) GetTransform() *Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

func (m *JobInfo) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *JobInfo) GetPipelineVersion() uint64 {
	if m != nil {
		return m.PipelineVersion
	}
	return 0
}

func (m *JobInfo) GetParallelismSpec() *ParallelismSpec {
	if m != nil {
		return m.ParallelismSpec
	}
	return nil
}

func (m *JobInfo) GetEgress() *Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *JobInfo) GetParentJob() *Job {
	if m != nil {
		return m.ParentJob
	}
	return nil
}

func (m *JobInfo) GetStarted() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *JobInfo) GetFinished() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Finished
	}
	return nil
}

func (m *JobInfo) GetOutputCommit() *pfs.Commit {
	if m != nil {
		return m.OutputCommit
	}
	return nil
}

func (m *JobInfo) GetState() JobState {
	if m != nil {
		return m.State
	}
	return JobState_JOB_STARTING
}

func (m *JobInfo) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *JobInfo) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *JobInfo) GetOutputRepo() *pfs.Repo {
	if m != nil {
		return m.OutputRepo
	}
	return nil
}

func (m *JobInfo) GetOutputBranch() string {
	if m != nil {
		return m.OutputBranch
	}
	return ""
}

func (m *JobInfo) GetRestart() uint64 {
	if m != nil {
		return m.Restart
	}
	return 0
}

func (m *JobInfo) GetDataProcessed() int64 {
	if m != nil {
		return m.DataProcessed
	}
	return 0
}

func (m *JobInfo) GetDataSkipped() int64 {
	if m != nil {
		return m.DataSkipped
	}
	return 0
}

func (m *JobInfo) GetDataFailed() int64 {
	if m != nil {
		return m.DataFailed
	}
	return 0
}

func (m *JobInfo) GetDataTotal() int64 {
	if m != nil {
		return m.DataTotal
	}
	return 0
}

func (m *JobInfo) GetStats() *ProcessStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *JobInfo) GetWorkerStatus() []*WorkerStatus {
	if m != nil {
		return m.WorkerStatus
	}
	return nil
}

func (m *JobInfo) GetResourceRequests() *ResourceSpec {
	if m != nil {
		return m.ResourceRequests
	}
	return nil
}

func (m *JobInfo) GetResourceLimits() *ResourceSpec {
	if m != nil {
		return m.ResourceLimits
	}
	return nil
}

func (m *JobInfo) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *JobInfo) GetNewBranch() *pfs.BranchInfo {
	if m != nil {
		return m.NewBranch
	}
	return nil
}

func (m *JobInfo) GetIncremental() bool {
	if m != nil {
		return m.Incremental
	}
	return false
}

func (m *JobInfo) GetStatsCommit() *pfs.Commit {
	if m != nil {
		return m.StatsCommit
	}
	return nil
}

func (m *JobInfo) GetEnableStats() bool {
	if m != nil {
		return m.EnableStats
	}
	return false
}

func (m *JobInfo) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *JobInfo) GetBatch() bool {
	if m != nil {
		return m.Batch
	}
	return false
}

func (m *JobInfo) GetChunkSpec() *ChunkSpec {
	if m != nil {
		return m.ChunkSpec
	}
	return nil
}

func (m *JobInfo) GetDatumTimeout() *google_protobuf2.Duration {
	if m != nil {
		return m.DatumTimeout
	}
	return nil
}

func (m *JobInfo) GetJobTimeout() *google_protobuf2.Duration {
	if m != nil {
		return m.JobTimeout
	}
	return nil
}

type Worker struct {
	Name  string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	State WorkerState `protobuf:"varint,2,opt,name=state,proto3,enum=pps.WorkerState" json:"state,omitempty"`
}

func (m *Worker) Reset()                    { *m = Worker{} }
func (m *Worker) String() string            { return proto.CompactTextString(m) }
func (*Worker) ProtoMessage()               {}
func (*Worker) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{21} }

func (m *Worker) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Worker) GetState() WorkerState {
	if m != nil {
		return m.State
	}
	return WorkerState_POD_RUNNING
}

type JobInfos struct {
	JobInfo []*JobInfo `protobuf:"bytes,1,rep,name=job_info,json=jobInfo" json:"job_info,omitempty"`
}

func (m *JobInfos) Reset()                    { *m = JobInfos{} }
func (m *JobInfos) String() string            { return proto.CompactTextString(m) }
func (*JobInfos) ProtoMessage()               {}
func (*JobInfos) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{22} }

func (m *JobInfos) GetJobInfo() []*JobInfo {
	if m != nil {
		return m.JobInfo
	}
	return nil
}

type Pipeline struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Pipeline) Reset()                    { *m = Pipeline{} }
func (m *Pipeline) String() string            { return proto.CompactTextString(m) }
func (*Pipeline) ProtoMessage()               {}
func (*Pipeline) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{23} }

func (m *Pipeline) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PipelineInput struct {
	Name   string      `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	Repo   *pfs.Repo   `protobuf:"bytes,1,opt,name=repo" json:"repo,omitempty"`
	Branch string      `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
	Glob   string      `protobuf:"bytes,3,opt,name=glob,proto3" json:"glob,omitempty"`
	Lazy   bool        `protobuf:"varint,4,opt,name=lazy,proto3" json:"lazy,omitempty"`
	From   *pfs.Commit `protobuf:"bytes,6,opt,name=from" json:"from,omitempty"`
}

func (m *PipelineInput) Reset()                    { *m = PipelineInput{} }
func (m *PipelineInput) String() string            { return proto.CompactTextString(m) }
func (*PipelineInput) ProtoMessage()               {}
func (*PipelineInput) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{24} }

func (m *PipelineInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PipelineInput) GetRepo() *pfs.Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *PipelineInput) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *PipelineInput) GetGlob() string {
	if m != nil {
		return m.Glob
	}
	return ""
}

func (m *PipelineInput) GetLazy() bool {
	if m != nil {
		return m.Lazy
	}
	return false
}

func (m *PipelineInput) GetFrom() *pfs.Commit {
	if m != nil {
		return m.From
	}
	return nil
}

// EtcdPipelineInfo is proto that Pachd stores in etcd for each pipeline. It
// tracks the state of the pipeline, and points to its metadata in PFS (and,
// by pointing to a PFS commit, de facto tracks the pipeline's version)
type EtcdPipelineInfo struct {
	State      PipelineState   `protobuf:"varint,1,opt,name=state,proto3,enum=pps.PipelineState" json:"state,omitempty"`
	Reason     string          `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	SpecCommit *pfs.Commit     `protobuf:"bytes,2,opt,name=spec_commit,json=specCommit" json:"spec_commit,omitempty"`
	JobCounts  map[int32]int32 `protobuf:"bytes,3,rep,name=job_counts,json=jobCounts" json:"job_counts,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	AuthToken  string          `protobuf:"bytes,5,opt,name=auth_token,json=authToken,proto3" json:"auth_token,omitempty"`
}

func (m *EtcdPipelineInfo) Reset()                    { *m = EtcdPipelineInfo{} }
func (m *EtcdPipelineInfo) String() string            { return proto.CompactTextString(m) }
func (*EtcdPipelineInfo) ProtoMessage()               {}
func (*EtcdPipelineInfo) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{25} }

func (m *EtcdPipelineInfo) GetState() PipelineState {
	if m != nil {
		return m.State
	}
	return PipelineState_PIPELINE_STARTING
}

func (m *EtcdPipelineInfo) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *EtcdPipelineInfo) GetSpecCommit() *pfs.Commit {
	if m != nil {
		return m.SpecCommit
	}
	return nil
}

func (m *EtcdPipelineInfo) GetJobCounts() map[int32]int32 {
	if m != nil {
		return m.JobCounts
	}
	return nil
}

func (m *EtcdPipelineInfo) GetAuthToken() string {
	if m != nil {
		return m.AuthToken
	}
	return ""
}

type PipelineInfo struct {
	ID              string                      `protobuf:"bytes,17,opt,name=id,proto3" json:"id,omitempty"`
	Pipeline        *Pipeline                   `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
	Version         uint64                      `protobuf:"varint,11,opt,name=version,proto3" json:"version,omitempty"`
	Transform       *Transform                  `protobuf:"bytes,2,opt,name=transform" json:"transform,omitempty"`
	ParallelismSpec *ParallelismSpec            `protobuf:"bytes,10,opt,name=parallelism_spec,json=parallelismSpec" json:"parallelism_spec,omitempty"`
	Egress          *Egress                     `protobuf:"bytes,15,opt,name=egress" json:"egress,omitempty"`
	CreatedAt       *google_protobuf1.Timestamp `protobuf:"bytes,6,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	// state indicates the current state of the pipeline. This is not stored in
	// PFS along with the rest of this data structure--PPS.InspectPipeline fills
	// it in
	State       PipelineState `protobuf:"varint,7,opt,name=state,proto3,enum=pps.PipelineState" json:"state,omitempty"`
	RecentError string        `protobuf:"bytes,8,opt,name=recent_error,json=recentError,proto3" json:"recent_error,omitempty"`
	// job_counts indicates the number of jobs within this pipeline in a given
	// state. This is not stored in PFS along with the rest of this data
	// structure--PPS.InspectPipeline fills it in
	JobCounts          map[int32]int32            `protobuf:"bytes,9,rep,name=job_counts,json=jobCounts" json:"job_counts,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	OutputBranch       string                     `protobuf:"bytes,16,opt,name=output_branch,json=outputBranch,proto3" json:"output_branch,omitempty"`
	ScaleDownThreshold *google_protobuf2.Duration `protobuf:"bytes,18,opt,name=scale_down_threshold,json=scaleDownThreshold" json:"scale_down_threshold,omitempty"`
	ResourceRequests   *ResourceSpec              `protobuf:"bytes,19,opt,name=resource_requests,json=resourceRequests" json:"resource_requests,omitempty"`
	ResourceLimits     *ResourceSpec              `protobuf:"bytes,31,opt,name=resource_limits,json=resourceLimits" json:"resource_limits,omitempty"`
	Input              *Input                     `protobuf:"bytes,20,opt,name=input" json:"input,omitempty"`
	Description        string                     `protobuf:"bytes,21,opt,name=description,proto3" json:"description,omitempty"`
	Incremental        bool                       `protobuf:"varint,22,opt,name=incremental,proto3" json:"incremental,omitempty"`
	CacheSize          string                     `protobuf:"bytes,23,opt,name=cache_size,json=cacheSize,proto3" json:"cache_size,omitempty"`
	EnableStats        bool                       `protobuf:"varint,24,opt,name=enable_stats,json=enableStats,proto3" json:"enable_stats,omitempty"`
	Salt               string                     `protobuf:"bytes,25,opt,name=salt,proto3" json:"salt,omitempty"`
	Batch              bool                       `protobuf:"varint,27,opt,name=batch,proto3" json:"batch,omitempty"`
	// reason includes any error messages associated with a failed pipeline
	Reason       string                     `protobuf:"bytes,28,opt,name=reason,proto3" json:"reason,omitempty"`
	MaxQueueSize int64                      `protobuf:"varint,29,opt,name=max_queue_size,json=maxQueueSize,proto3" json:"max_queue_size,omitempty"`
	Service      *Service                   `protobuf:"bytes,30,opt,name=service" json:"service,omitempty"`
	ChunkSpec    *ChunkSpec                 `protobuf:"bytes,32,opt,name=chunk_spec,json=chunkSpec" json:"chunk_spec,omitempty"`
	DatumTimeout *google_protobuf2.Duration `protobuf:"bytes,33,opt,name=datum_timeout,json=datumTimeout" json:"datum_timeout,omitempty"`
	JobTimeout   *google_protobuf2.Duration `protobuf:"bytes,34,opt,name=job_timeout,json=jobTimeout" json:"job_timeout,omitempty"`
	GithookURL   string                     `protobuf:"bytes,35,opt,name=githook_url,json=githookUrl,proto3" json:"githook_url,omitempty"`
	SpecCommit   *pfs.Commit                `protobuf:"bytes,36,opt,name=spec_commit,json=specCommit" json:"spec_commit,omitempty"`
}

func (m *PipelineInfo) Reset()                    { *m = PipelineInfo{} }
func (m *PipelineInfo) String() string            { return proto.CompactTextString(m) }
func (*PipelineInfo) ProtoMessage()               {}
func (*PipelineInfo) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{26} }

func (m *PipelineInfo) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *PipelineInfo) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *PipelineInfo) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *PipelineInfo) GetTransform() *Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

func (m *PipelineInfo) GetParallelismSpec() *ParallelismSpec {
	if m != nil {
		return m.ParallelismSpec
	}
	return nil
}

func (m *PipelineInfo) GetEgress() *Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *PipelineInfo) GetCreatedAt() *google_protobuf1.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *PipelineInfo) GetState() PipelineState {
	if m != nil {
		return m.State
	}
	return PipelineState_PIPELINE_STARTING
}

func (m *PipelineInfo) GetRecentError() string {
	if m != nil {
		return m.RecentError
	}
	return ""
}

func (m *PipelineInfo) GetJobCounts() map[int32]int32 {
	if m != nil {
		return m.JobCounts
	}
	return nil
}

func (m *PipelineInfo) GetOutputBranch() string {
	if m != nil {
		return m.OutputBranch
	}
	return ""
}

func (m *PipelineInfo) GetScaleDownThreshold() *google_protobuf2.Duration {
	if m != nil {
		return m.ScaleDownThreshold
	}
	return nil
}

func (m *PipelineInfo) GetResourceRequests() *ResourceSpec {
	if m != nil {
		return m.ResourceRequests
	}
	return nil
}

func (m *PipelineInfo) GetResourceLimits() *ResourceSpec {
	if m != nil {
		return m.ResourceLimits
	}
	return nil
}

func (m *PipelineInfo) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *PipelineInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PipelineInfo) GetIncremental() bool {
	if m != nil {
		return m.Incremental
	}
	return false
}

func (m *PipelineInfo) GetCacheSize() string {
	if m != nil {
		return m.CacheSize
	}
	return ""
}

func (m *PipelineInfo) GetEnableStats() bool {
	if m != nil {
		return m.EnableStats
	}
	return false
}

func (m *PipelineInfo) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *PipelineInfo) GetBatch() bool {
	if m != nil {
		return m.Batch
	}
	return false
}

func (m *PipelineInfo) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *PipelineInfo) GetMaxQueueSize() int64 {
	if m != nil {
		return m.MaxQueueSize
	}
	return 0
}

func (m *PipelineInfo) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *PipelineInfo) GetChunkSpec() *ChunkSpec {
	if m != nil {
		return m.ChunkSpec
	}
	return nil
}

func (m *PipelineInfo) GetDatumTimeout() *google_protobuf2.Duration {
	if m != nil {
		return m.DatumTimeout
	}
	return nil
}

func (m *PipelineInfo) GetJobTimeout() *google_protobuf2.Duration {
	if m != nil {
		return m.JobTimeout
	}
	return nil
}

func (m *PipelineInfo) GetGithookURL() string {
	if m != nil {
		return m.GithookURL
	}
	return ""
}

func (m *PipelineInfo) GetSpecCommit() *pfs.Commit {
	if m != nil {
		return m.SpecCommit
	}
	return nil
}

type PipelineInfos struct {
	PipelineInfo []*PipelineInfo `protobuf:"bytes,1,rep,name=pipeline_info,json=pipelineInfo" json:"pipeline_info,omitempty"`
}

func (m *PipelineInfos) Reset()                    { *m = PipelineInfos{} }
func (m *PipelineInfos) String() string            { return proto.CompactTextString(m) }
func (*PipelineInfos) ProtoMessage()               {}
func (*PipelineInfos) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{27} }

func (m *PipelineInfos) GetPipelineInfo() []*PipelineInfo {
	if m != nil {
		return m.PipelineInfo
	}
	return nil
}

type CreateJobRequest struct {
	Pipeline     *Pipeline   `protobuf:"bytes,2,opt,name=pipeline" json:"pipeline,omitempty"`
	OutputCommit *pfs.Commit `protobuf:"bytes,25,opt,name=output_commit,json=outputCommit" json:"output_commit,omitempty"`
}

func (m *CreateJobRequest) Reset()                    { *m = CreateJobRequest{} }
func (m *CreateJobRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateJobRequest) ProtoMessage()               {}
func (*CreateJobRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{28} }

func (m *CreateJobRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *CreateJobRequest) GetOutputCommit() *pfs.Commit {
	if m != nil {
		return m.OutputCommit
	}
	return nil
}

type InspectJobRequest struct {
	Job        *Job `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
	BlockState bool `protobuf:"varint,2,opt,name=block_state,json=blockState,proto3" json:"block_state,omitempty"`
}

func (m *InspectJobRequest) Reset()                    { *m = InspectJobRequest{} }
func (m *InspectJobRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectJobRequest) ProtoMessage()               {}
func (*InspectJobRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{29} }

func (m *InspectJobRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *InspectJobRequest) GetBlockState() bool {
	if m != nil {
		return m.BlockState
	}
	return false
}

type ListJobRequest struct {
	Pipeline     *Pipeline     `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
	InputCommit  []*pfs.Commit `protobuf:"bytes,2,rep,name=input_commit,json=inputCommit" json:"input_commit,omitempty"`
	OutputCommit *pfs.Commit   `protobuf:"bytes,3,opt,name=output_commit,json=outputCommit" json:"output_commit,omitempty"`
}

func (m *ListJobRequest) Reset()                    { *m = ListJobRequest{} }
func (m *ListJobRequest) String() string            { return proto.CompactTextString(m) }
func (*ListJobRequest) ProtoMessage()               {}
func (*ListJobRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{30} }

func (m *ListJobRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *ListJobRequest) GetInputCommit() []*pfs.Commit {
	if m != nil {
		return m.InputCommit
	}
	return nil
}

func (m *ListJobRequest) GetOutputCommit() *pfs.Commit {
	if m != nil {
		return m.OutputCommit
	}
	return nil
}

type FlushJobRequest struct {
	Commits     []*pfs.Commit `protobuf:"bytes,1,rep,name=commits" json:"commits,omitempty"`
	ToPipelines []*Pipeline   `protobuf:"bytes,2,rep,name=to_pipelines,json=toPipelines" json:"to_pipelines,omitempty"`
}

func (m *FlushJobRequest) Reset()                    { *m = FlushJobRequest{} }
func (m *FlushJobRequest) String() string            { return proto.CompactTextString(m) }
func (*FlushJobRequest) ProtoMessage()               {}
func (*FlushJobRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{31} }

func (m *FlushJobRequest) GetCommits() []*pfs.Commit {
	if m != nil {
		return m.Commits
	}
	return nil
}

func (m *FlushJobRequest) GetToPipelines() []*Pipeline {
	if m != nil {
		return m.ToPipelines
	}
	return nil
}

type DeleteJobRequest struct {
	Job *Job `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
}

func (m *DeleteJobRequest) Reset()                    { *m = DeleteJobRequest{} }
func (m *DeleteJobRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteJobRequest) ProtoMessage()               {}
func (*DeleteJobRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{32} }

func (m *DeleteJobRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type StopJobRequest struct {
	Job *Job `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
}

func (m *StopJobRequest) Reset()                    { *m = StopJobRequest{} }
func (m *StopJobRequest) String() string            { return proto.CompactTextString(m) }
func (*StopJobRequest) ProtoMessage()               {}
func (*StopJobRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{33} }

func (m *StopJobRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type GetLogsRequest struct {
	// The pipeline from which we want to get logs (required if the job in 'job'
	// was created as part of a pipeline. To get logs from a non-orphan job
	// without the pipeline that created it, you need to use ElasticSearch).
	Pipeline *Pipeline `protobuf:"bytes,2,opt,name=pipeline" json:"pipeline,omitempty"`
	// The job from which we want to get logs.
	Job *Job `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
	// Names of input files from which we want processing logs. This may contain
	// multiple files, to query pipelines that contain multiple inputs. Each
	// filter may be an absolute path of a file within a pps repo, or it may be
	// a hash for that file (to search for files at specific versions)
	DataFilters []string `protobuf:"bytes,3,rep,name=data_filters,json=dataFilters" json:"data_filters,omitempty"`
	Datum       *Datum   `protobuf:"bytes,6,opt,name=datum" json:"datum,omitempty"`
	// If true get logs from the master process
	Master bool `protobuf:"varint,5,opt,name=master,proto3" json:"master,omitempty"`
	// Continue to follow new logs as they become available.
	Follow bool `protobuf:"varint,7,opt,name=follow,proto3" json:"follow,omitempty"`
	// If nonzero, the number of lines from the end of the logs to return.  Note:
	// tail applies per container, so you will get tail * <number of pods> total
	// lines back.
	Tail int64 `protobuf:"varint,8,opt,name=tail,proto3" json:"tail,omitempty"`
}

func (m *GetLogsRequest) Reset()                    { *m = GetLogsRequest{} }
func (m *GetLogsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLogsRequest) ProtoMessage()               {}
func (*GetLogsRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{34} }

func (m *GetLogsRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *GetLogsRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *GetLogsRequest) GetDataFilters() []string {
	if m != nil {
		return m.DataFilters
	}
	return nil
}

func (m *GetLogsRequest) GetDatum() *Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

func (m *GetLogsRequest) GetMaster() bool {
	if m != nil {
		return m.Master
	}
	return false
}

func (m *GetLogsRequest) GetFollow() bool {
	if m != nil {
		return m.Follow
	}
	return false
}

func (m *GetLogsRequest) GetTail() int64 {
	if m != nil {
		return m.Tail
	}
	return 0
}

// LogMessage is a log line from a PPS worker, annotated with metadata
// indicating when and why the line was logged.
type LogMessage struct {
	// The job and pipeline for which a PFS file is being processed (if the job
	// is an orphan job, pipeline name and ID will be unset)
	PipelineName string `protobuf:"bytes,1,opt,name=pipeline_name,json=pipelineName,proto3" json:"pipeline_name,omitempty"`
	JobID        string `protobuf:"bytes,3,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	WorkerID     string `protobuf:"bytes,7,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty"`
	DatumID      string `protobuf:"bytes,9,opt,name=datum_id,json=datumId,proto3" json:"datum_id,omitempty"`
	Master       bool   `protobuf:"varint,10,opt,name=master,proto3" json:"master,omitempty"`
	// The PFS files being processed (one per pipeline/job input)
	Data []*InputFile `protobuf:"bytes,4,rep,name=data" json:"data,omitempty"`
	// User is true if log message comes from the users code.
	User bool `protobuf:"varint,8,opt,name=user,proto3" json:"user,omitempty"`
	// The message logged, and the time at which it was logged
	Ts      *google_protobuf1.Timestamp `protobuf:"bytes,5,opt,name=ts" json:"ts,omitempty"`
	Message string                      `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *LogMessage) Reset()                    { *m = LogMessage{} }
func (m *LogMessage) String() string            { return proto.CompactTextString(m) }
func (*LogMessage) ProtoMessage()               {}
func (*LogMessage) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{35} }

func (m *LogMessage) GetPipelineName() string {
	if m != nil {
		return m.PipelineName
	}
	return ""
}

func (m *LogMessage) GetJobID() string {
	if m != nil {
		return m.JobID
	}
	return ""
}

func (m *LogMessage) GetWorkerID() string {
	if m != nil {
		return m.WorkerID
	}
	return ""
}

func (m *LogMessage) GetDatumID() string {
	if m != nil {
		return m.DatumID
	}
	return ""
}

func (m *LogMessage) GetMaster() bool {
	if m != nil {
		return m.Master
	}
	return false
}

func (m *LogMessage) GetData() []*InputFile {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *LogMessage) GetUser() bool {
	if m != nil {
		return m.User
	}
	return false
}

func (m *LogMessage) GetTs() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *LogMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type RestartDatumRequest struct {
	Job         *Job     `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
	DataFilters []string `protobuf:"bytes,2,rep,name=data_filters,json=dataFilters" json:"data_filters,omitempty"`
}

func (m *RestartDatumRequest) Reset()                    { *m = RestartDatumRequest{} }
func (m *RestartDatumRequest) String() string            { return proto.CompactTextString(m) }
func (*RestartDatumRequest) ProtoMessage()               {}
func (*RestartDatumRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{36} }

func (m *RestartDatumRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *RestartDatumRequest) GetDataFilters() []string {
	if m != nil {
		return m.DataFilters
	}
	return nil
}

type InspectDatumRequest struct {
	Datum *Datum `protobuf:"bytes,1,opt,name=datum" json:"datum,omitempty"`
}

func (m *InspectDatumRequest) Reset()                    { *m = InspectDatumRequest{} }
func (m *InspectDatumRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectDatumRequest) ProtoMessage()               {}
func (*InspectDatumRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{37} }

func (m *InspectDatumRequest) GetDatum() *Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

type ListDatumRequest struct {
	Job      *Job  `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
	PageSize int64 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	Page     int64 `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
}

func (m *ListDatumRequest) Reset()                    { *m = ListDatumRequest{} }
func (m *ListDatumRequest) String() string            { return proto.CompactTextString(m) }
func (*ListDatumRequest) ProtoMessage()               {}
func (*ListDatumRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{38} }

func (m *ListDatumRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *ListDatumRequest) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListDatumRequest) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

type ListDatumResponse struct {
	DatumInfos []*DatumInfo `protobuf:"bytes,1,rep,name=datum_infos,json=datumInfos" json:"datum_infos,omitempty"`
	TotalPages int64        `protobuf:"varint,2,opt,name=total_pages,json=totalPages,proto3" json:"total_pages,omitempty"`
	Page       int64        `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
}

func (m *ListDatumResponse) Reset()                    { *m = ListDatumResponse{} }
func (m *ListDatumResponse) String() string            { return proto.CompactTextString(m) }
func (*ListDatumResponse) ProtoMessage()               {}
func (*ListDatumResponse) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{39} }

func (m *ListDatumResponse) GetDatumInfos() []*DatumInfo {
	if m != nil {
		return m.DatumInfos
	}
	return nil
}

func (m *ListDatumResponse) GetTotalPages() int64 {
	if m != nil {
		return m.TotalPages
	}
	return 0
}

func (m *ListDatumResponse) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

// ListDatumStreamResponse is identical to ListDatumResponse, except that only
// one DatumInfo is present (as these responses are streamed)
type ListDatumStreamResponse struct {
	DatumInfo *DatumInfo `protobuf:"bytes,1,opt,name=datum_info,json=datumInfo" json:"datum_info,omitempty"`
	// total_pages is only set in the first response (and set to 0 in all other
	// responses)
	TotalPages int64 `protobuf:"varint,2,opt,name=total_pages,json=totalPages,proto3" json:"total_pages,omitempty"`
	// page is only set in the first response (and set to 0 in all other
	// responses)
	Page int64 `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
}

func (m *ListDatumStreamResponse) Reset()                    { *m = ListDatumStreamResponse{} }
func (m *ListDatumStreamResponse) String() string            { return proto.CompactTextString(m) }
func (*ListDatumStreamResponse) ProtoMessage()               {}
func (*ListDatumStreamResponse) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{40} }

func (m *ListDatumStreamResponse) GetDatumInfo() *DatumInfo {
	if m != nil {
		return m.DatumInfo
	}
	return nil
}

func (m *ListDatumStreamResponse) GetTotalPages() int64 {
	if m != nil {
		return m.TotalPages
	}
	return 0
}

func (m *ListDatumStreamResponse) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

// ChunkSpec specifies how a pipeline should chunk its datums.
type ChunkSpec struct {
	// number, if nonzero, specifies that each chunk should contain `number`
	// datums. Chunks may contain fewer if the total number of datums don't
	// divide evenly.
	Number int64 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// size_bytes, if nonzero, specifies a target size for each chunk of datums.
	// Chunks may be larger or smaller than size_bytes, but will usually be
	// pretty close to size_bytes in size.
	SizeBytes int64 `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
}

func (m *ChunkSpec) Reset()                    { *m = ChunkSpec{} }
func (m *ChunkSpec) String() string            { return proto.CompactTextString(m) }
func (*ChunkSpec) ProtoMessage()               {}
func (*ChunkSpec) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{41} }

func (m *ChunkSpec) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *ChunkSpec) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

type CreatePipelineRequest struct {
	Pipeline           *Pipeline                  `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
	Transform          *Transform                 `protobuf:"bytes,2,opt,name=transform" json:"transform,omitempty"`
	ParallelismSpec    *ParallelismSpec           `protobuf:"bytes,7,opt,name=parallelism_spec,json=parallelismSpec" json:"parallelism_spec,omitempty"`
	Egress             *Egress                    `protobuf:"bytes,9,opt,name=egress" json:"egress,omitempty"`
	Update             bool                       `protobuf:"varint,5,opt,name=update,proto3" json:"update,omitempty"`
	OutputBranch       string                     `protobuf:"bytes,10,opt,name=output_branch,json=outputBranch,proto3" json:"output_branch,omitempty"`
	ScaleDownThreshold *google_protobuf2.Duration `protobuf:"bytes,11,opt,name=scale_down_threshold,json=scaleDownThreshold" json:"scale_down_threshold,omitempty"`
	ResourceRequests   *ResourceSpec              `protobuf:"bytes,12,opt,name=resource_requests,json=resourceRequests" json:"resource_requests,omitempty"`
	ResourceLimits     *ResourceSpec              `protobuf:"bytes,22,opt,name=resource_limits,json=resourceLimits" json:"resource_limits,omitempty"`
	Input              *Input                     `protobuf:"bytes,13,opt,name=input" json:"input,omitempty"`
	Description        string                     `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	Incremental        bool                       `protobuf:"varint,15,opt,name=incremental,proto3" json:"incremental,omitempty"`
	CacheSize          string                     `protobuf:"bytes,16,opt,name=cache_size,json=cacheSize,proto3" json:"cache_size,omitempty"`
	EnableStats        bool                       `protobuf:"varint,17,opt,name=enable_stats,json=enableStats,proto3" json:"enable_stats,omitempty"`
	// Reprocess forces the pipeline to reprocess all datums.
	// It only has meaning if Update is true
	Reprocess    bool                       `protobuf:"varint,18,opt,name=reprocess,proto3" json:"reprocess,omitempty"`
	Batch        bool                       `protobuf:"varint,19,opt,name=batch,proto3" json:"batch,omitempty"`
	MaxQueueSize int64                      `protobuf:"varint,20,opt,name=max_queue_size,json=maxQueueSize,proto3" json:"max_queue_size,omitempty"`
	Service      *Service                   `protobuf:"bytes,21,opt,name=service" json:"service,omitempty"`
	ChunkSpec    *ChunkSpec                 `protobuf:"bytes,23,opt,name=chunk_spec,json=chunkSpec" json:"chunk_spec,omitempty"`
	DatumTimeout *google_protobuf2.Duration `protobuf:"bytes,24,opt,name=datum_timeout,json=datumTimeout" json:"datum_timeout,omitempty"`
	JobTimeout   *google_protobuf2.Duration `protobuf:"bytes,25,opt,name=job_timeout,json=jobTimeout" json:"job_timeout,omitempty"`
	Salt         string                     `protobuf:"bytes,26,opt,name=salt,proto3" json:"salt,omitempty"`
}

func (m *CreatePipelineRequest) Reset()                    { *m = CreatePipelineRequest{} }
func (m *CreatePipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*CreatePipelineRequest) ProtoMessage()               {}
func (*CreatePipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{42} }

func (m *CreatePipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *CreatePipelineRequest) GetTransform() *Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

func (m *CreatePipelineRequest) GetParallelismSpec() *ParallelismSpec {
	if m != nil {
		return m.ParallelismSpec
	}
	return nil
}

func (m *CreatePipelineRequest) GetEgress() *Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *CreatePipelineRequest) GetUpdate() bool {
	if m != nil {
		return m.Update
	}
	return false
}

func (m *CreatePipelineRequest) GetOutputBranch() string {
	if m != nil {
		return m.OutputBranch
	}
	return ""
}

func (m *CreatePipelineRequest) GetScaleDownThreshold() *google_protobuf2.Duration {
	if m != nil {
		return m.ScaleDownThreshold
	}
	return nil
}

func (m *CreatePipelineRequest) GetResourceRequests() *ResourceSpec {
	if m != nil {
		return m.ResourceRequests
	}
	return nil
}

func (m *CreatePipelineRequest) GetResourceLimits() *ResourceSpec {
	if m != nil {
		return m.ResourceLimits
	}
	return nil
}

func (m *CreatePipelineRequest) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *CreatePipelineRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreatePipelineRequest) GetIncremental() bool {
	if m != nil {
		return m.Incremental
	}
	return false
}

func (m *CreatePipelineRequest) GetCacheSize() string {
	if m != nil {
		return m.CacheSize
	}
	return ""
}

func (m *CreatePipelineRequest) GetEnableStats() bool {
	if m != nil {
		return m.EnableStats
	}
	return false
}

func (m *CreatePipelineRequest) GetReprocess() bool {
	if m != nil {
		return m.Reprocess
	}
	return false
}

func (m *CreatePipelineRequest) GetBatch() bool {
	if m != nil {
		return m.Batch
	}
	return false
}

func (m *CreatePipelineRequest) GetMaxQueueSize() int64 {
	if m != nil {
		return m.MaxQueueSize
	}
	return 0
}

func (m *CreatePipelineRequest) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *CreatePipelineRequest) GetChunkSpec() *ChunkSpec {
	if m != nil {
		return m.ChunkSpec
	}
	return nil
}

func (m *CreatePipelineRequest) GetDatumTimeout() *google_protobuf2.Duration {
	if m != nil {
		return m.DatumTimeout
	}
	return nil
}

func (m *CreatePipelineRequest) GetJobTimeout() *google_protobuf2.Duration {
	if m != nil {
		return m.JobTimeout
	}
	return nil
}

func (m *CreatePipelineRequest) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

type InspectPipelineRequest struct {
	Pipeline *Pipeline `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
}

func (m *InspectPipelineRequest) Reset()                    { *m = InspectPipelineRequest{} }
func (m *InspectPipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectPipelineRequest) ProtoMessage()               {}
func (*InspectPipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{43} }

func (m *InspectPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

type ListPipelineRequest struct {
}

func (m *ListPipelineRequest) Reset()                    { *m = ListPipelineRequest{} }
func (m *ListPipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPipelineRequest) ProtoMessage()               {}
func (*ListPipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{44} }

type DeletePipelineRequest struct {
	Pipeline *Pipeline `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
	All      bool      `protobuf:"varint,4,opt,name=all,proto3" json:"all,omitempty"`
}

func (m *DeletePipelineRequest) Reset()                    { *m = DeletePipelineRequest{} }
func (m *DeletePipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*DeletePipelineRequest) ProtoMessage()               {}
func (*DeletePipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{45} }

func (m *DeletePipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *DeletePipelineRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

type StartPipelineRequest struct {
	Pipeline *Pipeline `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
}

func (m *StartPipelineRequest) Reset()                    { *m = StartPipelineRequest{} }
func (m *StartPipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*StartPipelineRequest) ProtoMessage()               {}
func (*StartPipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{46} }

func (m *StartPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

type StopPipelineRequest struct {
	Pipeline *Pipeline `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
}

func (m *StopPipelineRequest) Reset()                    { *m = StopPipelineRequest{} }
func (m *StopPipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*StopPipelineRequest) ProtoMessage()               {}
func (*StopPipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{47} }

func (m *StopPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

type RerunPipelineRequest struct {
	Pipeline *Pipeline     `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
	Exclude  []*pfs.Commit `protobuf:"bytes,2,rep,name=exclude" json:"exclude,omitempty"`
	Include  []*pfs.Commit `protobuf:"bytes,3,rep,name=include" json:"include,omitempty"`
}

func (m *RerunPipelineRequest) Reset()                    { *m = RerunPipelineRequest{} }
func (m *RerunPipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*RerunPipelineRequest) ProtoMessage()               {}
func (*RerunPipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{48} }

func (m *RerunPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *RerunPipelineRequest) GetExclude() []*pfs.Commit {
	if m != nil {
		return m.Exclude
	}
	return nil
}

func (m *RerunPipelineRequest) GetInclude() []*pfs.Commit {
	if m != nil {
		return m.Include
	}
	return nil
}

type GarbageCollectRequest struct {
}

func (m *GarbageCollectRequest) Reset()                    { *m = GarbageCollectRequest{} }
func (m *GarbageCollectRequest) String() string            { return proto.CompactTextString(m) }
func (*GarbageCollectRequest) ProtoMessage()               {}
func (*GarbageCollectRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{49} }

type GarbageCollectResponse struct {
}

func (m *GarbageCollectResponse) Reset()                    { *m = GarbageCollectResponse{} }
func (m *GarbageCollectResponse) String() string            { return proto.CompactTextString(m) }
func (*GarbageCollectResponse) ProtoMessage()               {}
func (*GarbageCollectResponse) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{50} }

type ActivateAuthRequest struct {
}

func (m *ActivateAuthRequest) Reset()                    { *m = ActivateAuthRequest{} }
func (m *ActivateAuthRequest) String() string            { return proto.CompactTextString(m) }
func (*ActivateAuthRequest) ProtoMessage()               {}
func (*ActivateAuthRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{51} }

type ActivateAuthResponse struct {
}

func (m *ActivateAuthResponse) Reset()                    { *m = ActivateAuthResponse{} }
func (m *ActivateAuthResponse) String() string            { return proto.CompactTextString(m) }
func (*ActivateAuthResponse) ProtoMessage()               {}
func (*ActivateAuthResponse) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{52} }

func init() {
	proto.RegisterType((*Secret)(nil), "pps.Secret")
	proto.RegisterType((*Transform)(nil), "pps.Transform")
	proto.RegisterType((*Egress)(nil), "pps.Egress")
	proto.RegisterType((*Job)(nil), "pps.Job")
	proto.RegisterType((*Service)(nil), "pps.Service")
	proto.RegisterType((*AtomInput)(nil), "pps.AtomInput")
	proto.RegisterType((*CronInput)(nil), "pps.CronInput")
	proto.RegisterType((*GitInput)(nil), "pps.GitInput")
	proto.RegisterType((*Input)(nil), "pps.Input")
	proto.RegisterType((*JobInput)(nil), "pps.JobInput")
	proto.RegisterType((*ParallelismSpec)(nil), "pps.ParallelismSpec")
	proto.RegisterType((*InputFile)(nil), "pps.InputFile")
	proto.RegisterType((*Datum)(nil), "pps.Datum")
	proto.RegisterType((*DatumInfo)(nil), "pps.DatumInfo")
	proto.RegisterType((*Aggregate)(nil), "pps.Aggregate")
	proto.RegisterType((*ProcessStats)(nil), "pps.ProcessStats")
	proto.RegisterType((*AggregateProcessStats)(nil), "pps.AggregateProcessStats")
	proto.RegisterType((*WorkerStatus)(nil), "pps.WorkerStatus")
	proto.RegisterType((*ResourceSpec)(nil), "pps.ResourceSpec")
	proto.RegisterType((*EtcdJobInfo)(nil), "pps.EtcdJobInfo")
	proto.RegisterType((*JobInfo)(nil), "pps.JobInfo")
	proto.RegisterType((*Worker)(nil), "pps.Worker")
	proto.RegisterType((*JobInfos)(nil), "pps.JobInfos")
	proto.RegisterType((*Pipeline)(nil), "pps.Pipeline")
	proto.RegisterType((*PipelineInput)(nil), "pps.PipelineInput")
	proto.RegisterType((*EtcdPipelineInfo)(nil), "pps.EtcdPipelineInfo")
	proto.RegisterType((*PipelineInfo)(nil), "pps.PipelineInfo")
	proto.RegisterType((*PipelineInfos)(nil), "pps.PipelineInfos")
	proto.RegisterType((*CreateJobRequest)(nil), "pps.CreateJobRequest")
	proto.RegisterType((*InspectJobRequest)(nil), "pps.InspectJobRequest")
	proto.RegisterType((*ListJobRequest)(nil), "pps.ListJobRequest")
	proto.RegisterType((*FlushJobRequest)(nil), "pps.FlushJobRequest")
	proto.RegisterType((*DeleteJobRequest)(nil), "pps.DeleteJobRequest")
	proto.RegisterType((*StopJobRequest)(nil), "pps.StopJobRequest")
	proto.RegisterType((*GetLogsRequest)(nil), "pps.GetLogsRequest")
	proto.RegisterType((*LogMessage)(nil), "pps.LogMessage")
	proto.RegisterType((*RestartDatumRequest)(nil), "pps.RestartDatumRequest")
	proto.RegisterType((*InspectDatumRequest)(nil), "pps.InspectDatumRequest")
	proto.RegisterType((*ListDatumRequest)(nil), "pps.ListDatumRequest")
	proto.RegisterType((*ListDatumResponse)(nil), "pps.ListDatumResponse")
	proto.RegisterType((*ListDatumStreamResponse)(nil), "pps.ListDatumStreamResponse")
	proto.RegisterType((*ChunkSpec)(nil), "pps.ChunkSpec")
	proto.RegisterType((*CreatePipelineRequest)(nil), "pps.CreatePipelineRequest")
	proto.RegisterType((*InspectPipelineRequest)(nil), "pps.InspectPipelineRequest")
	proto.RegisterType((*ListPipelineRequest)(nil), "pps.ListPipelineRequest")
	proto.RegisterType((*DeletePipelineRequest)(nil), "pps.DeletePipelineRequest")
	proto.RegisterType((*StartPipelineRequest)(nil), "pps.StartPipelineRequest")
	proto.RegisterType((*StopPipelineRequest)(nil), "pps.StopPipelineRequest")
	proto.RegisterType((*RerunPipelineRequest)(nil), "pps.RerunPipelineRequest")
	proto.RegisterType((*GarbageCollectRequest)(nil), "pps.GarbageCollectRequest")
	proto.RegisterType((*GarbageCollectResponse)(nil), "pps.GarbageCollectResponse")
	proto.RegisterType((*ActivateAuthRequest)(nil), "pps.ActivateAuthRequest")
	proto.RegisterType((*ActivateAuthResponse)(nil), "pps.ActivateAuthResponse")
	proto.RegisterEnum("pps.JobState", JobState_name, JobState_value)
	proto.RegisterEnum("pps.DatumState", DatumState_name, DatumState_value)
	proto.RegisterEnum("pps.WorkerState", WorkerState_name, WorkerState_value)
	proto.RegisterEnum("pps.PipelineState", PipelineState_name, PipelineState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for API service

type APIClient interface {
	CreateJob(ctx context.Context, in *CreateJobRequest, opts ...grpc.CallOption) (*Job, error)
	InspectJob(ctx context.Context, in *InspectJobRequest, opts ...grpc.CallOption) (*JobInfo, error)
	// ListJob returns information about current and past Pachyderm jobs. This is
	// deprecated in favor of ListJobStream
	ListJob(ctx context.Context, in *ListJobRequest, opts ...grpc.CallOption) (*JobInfos, error)
	// ListJobStream returns information about current and past Pachyderm jobs.
	ListJobStream(ctx context.Context, in *ListJobRequest, opts ...grpc.CallOption) (API_ListJobStreamClient, error)
	FlushJob(ctx context.Context, in *FlushJobRequest, opts ...grpc.CallOption) (API_FlushJobClient, error)
	DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	StopJob(ctx context.Context, in *StopJobRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	InspectDatum(ctx context.Context, in *InspectDatumRequest, opts ...grpc.CallOption) (*DatumInfo, error)
	// ListDatum returns information about each datum fed to a Pachyderm job. This
	// is deprecated in favor of ListDatumStream
	ListDatum(ctx context.Context, in *ListDatumRequest, opts ...grpc.CallOption) (*ListDatumResponse, error)
	// ListDatumStream returns information about each datum fed to a Pachyderm job
	ListDatumStream(ctx context.Context, in *ListDatumRequest, opts ...grpc.CallOption) (API_ListDatumStreamClient, error)
	RestartDatum(ctx context.Context, in *RestartDatumRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	CreatePipeline(ctx context.Context, in *CreatePipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	InspectPipeline(ctx context.Context, in *InspectPipelineRequest, opts ...grpc.CallOption) (*PipelineInfo, error)
	ListPipeline(ctx context.Context, in *ListPipelineRequest, opts ...grpc.CallOption) (*PipelineInfos, error)
	DeletePipeline(ctx context.Context, in *DeletePipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	StartPipeline(ctx context.Context, in *StartPipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	StopPipeline(ctx context.Context, in *StopPipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	RerunPipeline(ctx context.Context, in *RerunPipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// DeleteAll deletes everything
	DeleteAll(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (API_GetLogsClient, error)
	// Garbage collection
	GarbageCollect(ctx context.Context, in *GarbageCollectRequest, opts ...grpc.CallOption) (*GarbageCollectResponse, error)
	// An internal call that causes PPS to put itself into an auth-enabled state
	// (all pipeline have tokens, correct permissions, etcd)
	ActivateAuth(ctx context.Context, in *ActivateAuthRequest, opts ...grpc.CallOption) (*ActivateAuthResponse, error)
}

type aPIClient struct {
	cc *grpc.ClientConn
}

func NewAPIClient(cc *grpc.ClientConn) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) CreateJob(ctx context.Context, in *CreateJobRequest, opts ...grpc.CallOption) (*Job, error) {
	out := new(Job)
	err := grpc.Invoke(ctx, "/pps.API/CreateJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectJob(ctx context.Context, in *InspectJobRequest, opts ...grpc.CallOption) (*JobInfo, error) {
	out := new(JobInfo)
	err := grpc.Invoke(ctx, "/pps.API/InspectJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListJob(ctx context.Context, in *ListJobRequest, opts ...grpc.CallOption) (*JobInfos, error) {
	out := new(JobInfos)
	err := grpc.Invoke(ctx, "/pps.API/ListJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListJobStream(ctx context.Context, in *ListJobRequest, opts ...grpc.CallOption) (API_ListJobStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_API_serviceDesc.Streams[0], c.cc, "/pps.API/ListJobStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListJobStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListJobStreamClient interface {
	Recv() (*JobInfo, error)
	grpc.ClientStream
}

type aPIListJobStreamClient struct {
	grpc.ClientStream
}

func (x *aPIListJobStreamClient) Recv() (*JobInfo, error) {
	m := new(JobInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) FlushJob(ctx context.Context, in *FlushJobRequest, opts ...grpc.CallOption) (API_FlushJobClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_API_serviceDesc.Streams[1], c.cc, "/pps.API/FlushJob", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIFlushJobClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_FlushJobClient interface {
	Recv() (*JobInfo, error)
	grpc.ClientStream
}

type aPIFlushJobClient struct {
	grpc.ClientStream
}

func (x *aPIFlushJobClient) Recv() (*JobInfo, error) {
	m := new(JobInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/DeleteJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StopJob(ctx context.Context, in *StopJobRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/StopJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectDatum(ctx context.Context, in *InspectDatumRequest, opts ...grpc.CallOption) (*DatumInfo, error) {
	out := new(DatumInfo)
	err := grpc.Invoke(ctx, "/pps.API/InspectDatum", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListDatum(ctx context.Context, in *ListDatumRequest, opts ...grpc.CallOption) (*ListDatumResponse, error) {
	out := new(ListDatumResponse)
	err := grpc.Invoke(ctx, "/pps.API/ListDatum", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListDatumStream(ctx context.Context, in *ListDatumRequest, opts ...grpc.CallOption) (API_ListDatumStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_API_serviceDesc.Streams[2], c.cc, "/pps.API/ListDatumStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListDatumStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListDatumStreamClient interface {
	Recv() (*ListDatumStreamResponse, error)
	grpc.ClientStream
}

type aPIListDatumStreamClient struct {
	grpc.ClientStream
}

func (x *aPIListDatumStreamClient) Recv() (*ListDatumStreamResponse, error) {
	m := new(ListDatumStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) RestartDatum(ctx context.Context, in *RestartDatumRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/RestartDatum", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CreatePipeline(ctx context.Context, in *CreatePipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/CreatePipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectPipeline(ctx context.Context, in *InspectPipelineRequest, opts ...grpc.CallOption) (*PipelineInfo, error) {
	out := new(PipelineInfo)
	err := grpc.Invoke(ctx, "/pps.API/InspectPipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListPipeline(ctx context.Context, in *ListPipelineRequest, opts ...grpc.CallOption) (*PipelineInfos, error) {
	out := new(PipelineInfos)
	err := grpc.Invoke(ctx, "/pps.API/ListPipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeletePipeline(ctx context.Context, in *DeletePipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/DeletePipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StartPipeline(ctx context.Context, in *StartPipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/StartPipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StopPipeline(ctx context.Context, in *StopPipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/StopPipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RerunPipeline(ctx context.Context, in *RerunPipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/RerunPipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteAll(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/DeleteAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (API_GetLogsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_API_serviceDesc.Streams[3], c.cc, "/pps.API/GetLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGetLogsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_GetLogsClient interface {
	Recv() (*LogMessage, error)
	grpc.ClientStream
}

type aPIGetLogsClient struct {
	grpc.ClientStream
}

func (x *aPIGetLogsClient) Recv() (*LogMessage, error) {
	m := new(LogMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) GarbageCollect(ctx context.Context, in *GarbageCollectRequest, opts ...grpc.CallOption) (*GarbageCollectResponse, error) {
	out := new(GarbageCollectResponse)
	err := grpc.Invoke(ctx, "/pps.API/GarbageCollect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ActivateAuth(ctx context.Context, in *ActivateAuthRequest, opts ...grpc.CallOption) (*ActivateAuthResponse, error) {
	out := new(ActivateAuthResponse)
	err := grpc.Invoke(ctx, "/pps.API/ActivateAuth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for API service

type APIServer interface {
	CreateJob(context.Context, *CreateJobRequest) (*Job, error)
	InspectJob(context.Context, *InspectJobRequest) (*JobInfo, error)
	// ListJob returns information about current and past Pachyderm jobs. This is
	// deprecated in favor of ListJobStream
	ListJob(context.Context, *ListJobRequest) (*JobInfos, error)
	// ListJobStream returns information about current and past Pachyderm jobs.
	ListJobStream(*ListJobRequest, API_ListJobStreamServer) error
	FlushJob(*FlushJobRequest, API_FlushJobServer) error
	DeleteJob(context.Context, *DeleteJobRequest) (*google_protobuf.Empty, error)
	StopJob(context.Context, *StopJobRequest) (*google_protobuf.Empty, error)
	InspectDatum(context.Context, *InspectDatumRequest) (*DatumInfo, error)
	// ListDatum returns information about each datum fed to a Pachyderm job. This
	// is deprecated in favor of ListDatumStream
	ListDatum(context.Context, *ListDatumRequest) (*ListDatumResponse, error)
	// ListDatumStream returns information about each datum fed to a Pachyderm job
	ListDatumStream(*ListDatumRequest, API_ListDatumStreamServer) error
	RestartDatum(context.Context, *RestartDatumRequest) (*google_protobuf.Empty, error)
	CreatePipeline(context.Context, *CreatePipelineRequest) (*google_protobuf.Empty, error)
	InspectPipeline(context.Context, *InspectPipelineRequest) (*PipelineInfo, error)
	ListPipeline(context.Context, *ListPipelineRequest) (*PipelineInfos, error)
	DeletePipeline(context.Context, *DeletePipelineRequest) (*google_protobuf.Empty, error)
	StartPipeline(context.Context, *StartPipelineRequest) (*google_protobuf.Empty, error)
	StopPipeline(context.Context, *StopPipelineRequest) (*google_protobuf.Empty, error)
	RerunPipeline(context.Context, *RerunPipelineRequest) (*google_protobuf.Empty, error)
	// DeleteAll deletes everything
	DeleteAll(context.Context, *google_protobuf.Empty) (*google_protobuf.Empty, error)
	GetLogs(*GetLogsRequest, API_GetLogsServer) error
	// Garbage collection
	GarbageCollect(context.Context, *GarbageCollectRequest) (*GarbageCollectResponse, error)
	// An internal call that causes PPS to put itself into an auth-enabled state
	// (all pipeline have tokens, correct permissions, etcd)
	ActivateAuth(context.Context, *ActivateAuthRequest) (*ActivateAuthResponse, error)
}

func RegisterAPIServer(s *grpc.Server, srv APIServer) {
	s.RegisterService(&_API_serviceDesc, srv)
}

func _API_CreateJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/CreateJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateJob(ctx, req.(*CreateJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/InspectJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectJob(ctx, req.(*InspectJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/ListJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListJob(ctx, req.(*ListJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListJobStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListJobRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListJobStream(m, &aPIListJobStreamServer{stream})
}

type API_ListJobStreamServer interface {
	Send(*JobInfo) error
	grpc.ServerStream
}

type aPIListJobStreamServer struct {
	grpc.ServerStream
}

func (x *aPIListJobStreamServer) Send(m *JobInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_FlushJob_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FlushJobRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).FlushJob(m, &aPIFlushJobServer{stream})
}

type API_FlushJobServer interface {
	Send(*JobInfo) error
	grpc.ServerStream
}

type aPIFlushJobServer struct {
	grpc.ServerStream
}

func (x *aPIFlushJobServer) Send(m *JobInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_DeleteJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/DeleteJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteJob(ctx, req.(*DeleteJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StopJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StopJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/StopJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StopJob(ctx, req.(*StopJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectDatum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectDatumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectDatum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/InspectDatum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectDatum(ctx, req.(*InspectDatumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListDatum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDatumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListDatum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/ListDatum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListDatum(ctx, req.(*ListDatumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListDatumStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListDatumRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListDatumStream(m, &aPIListDatumStreamServer{stream})
}

type API_ListDatumStreamServer interface {
	Send(*ListDatumStreamResponse) error
	grpc.ServerStream
}

type aPIListDatumStreamServer struct {
	grpc.ServerStream
}

func (x *aPIListDatumStreamServer) Send(m *ListDatumStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _API_RestartDatum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestartDatumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RestartDatum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/RestartDatum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RestartDatum(ctx, req.(*RestartDatumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CreatePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreatePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/CreatePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreatePipeline(ctx, req.(*CreatePipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/InspectPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectPipeline(ctx, req.(*InspectPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/ListPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListPipeline(ctx, req.(*ListPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeletePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeletePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/DeletePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeletePipeline(ctx, req.(*DeletePipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StartPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StartPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/StartPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StartPipeline(ctx, req.(*StartPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StopPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StopPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/StopPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StopPipeline(ctx, req.(*StopPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RerunPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RerunPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RerunPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/RerunPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RerunPipeline(ctx, req.(*RerunPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/DeleteAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteAll(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).GetLogs(m, &aPIGetLogsServer{stream})
}

type API_GetLogsServer interface {
	Send(*LogMessage) error
	grpc.ServerStream
}

type aPIGetLogsServer struct {
	grpc.ServerStream
}

func (x *aPIGetLogsServer) Send(m *LogMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _API_GarbageCollect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GarbageCollectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GarbageCollect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/GarbageCollect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GarbageCollect(ctx, req.(*GarbageCollectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ActivateAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivateAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ActivateAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/ActivateAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ActivateAuth(ctx, req.(*ActivateAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _API_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pps.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateJob",
			Handler:    _API_CreateJob_Handler,
		},
		{
			MethodName: "InspectJob",
			Handler:    _API_InspectJob_Handler,
		},
		{
			MethodName: "ListJob",
			Handler:    _API_ListJob_Handler,
		},
		{
			MethodName: "DeleteJob",
			Handler:    _API_DeleteJob_Handler,
		},
		{
			MethodName: "StopJob",
			Handler:    _API_StopJob_Handler,
		},
		{
			MethodName: "InspectDatum",
			Handler:    _API_InspectDatum_Handler,
		},
		{
			MethodName: "ListDatum",
			Handler:    _API_ListDatum_Handler,
		},
		{
			MethodName: "RestartDatum",
			Handler:    _API_RestartDatum_Handler,
		},
		{
			MethodName: "CreatePipeline",
			Handler:    _API_CreatePipeline_Handler,
		},
		{
			MethodName: "InspectPipeline",
			Handler:    _API_InspectPipeline_Handler,
		},
		{
			MethodName: "ListPipeline",
			Handler:    _API_ListPipeline_Handler,
		},
		{
			MethodName: "DeletePipeline",
			Handler:    _API_DeletePipeline_Handler,
		},
		{
			MethodName: "StartPipeline",
			Handler:    _API_StartPipeline_Handler,
		},
		{
			MethodName: "StopPipeline",
			Handler:    _API_StopPipeline_Handler,
		},
		{
			MethodName: "RerunPipeline",
			Handler:    _API_RerunPipeline_Handler,
		},
		{
			MethodName: "DeleteAll",
			Handler:    _API_DeleteAll_Handler,
		},
		{
			MethodName: "GarbageCollect",
			Handler:    _API_GarbageCollect_Handler,
		},
		{
			MethodName: "ActivateAuth",
			Handler:    _API_ActivateAuth_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListJobStream",
			Handler:       _API_ListJobStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FlushJob",
			Handler:       _API_FlushJob_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListDatumStream",
			Handler:       _API_ListDatumStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetLogs",
			Handler:       _API_GetLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "client/pps/pps.proto",
}

func (m *Secret) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Secret) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.MountPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.MountPath)))
		i += copy(dAtA[i:], m.MountPath)
	}
	if len(m.EnvVar) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.EnvVar)))
		i += copy(dAtA[i:], m.EnvVar)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *Transform) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transform) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Image) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Cmd) > 0 {
		for _, s := range m.Cmd {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0x1a
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovPps(uint64(len(k))) + 1 + len(v) + sovPps(uint64(len(v)))
			i = encodeVarintPps(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Secrets) > 0 {
		for _, msg := range m.Secrets {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Stdin) > 0 {
		for _, s := range m.Stdin {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AcceptReturnCode) > 0 {
		dAtA2 := make([]byte, len(m.AcceptReturnCode)*10)
		var j1 int
		for _, num1 := range m.AcceptReturnCode {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.Debug {
		dAtA[i] = 0x38
		i++
		if m.Debug {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ImagePullSecrets) > 0 {
		for _, s := range m.ImagePullSecrets {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Egress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Egress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URL) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.URL)))
		i += copy(dAtA[i:], m.URL)
	}
	return i, nil
}

func (m *Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	return i, nil
}

func (m *Service) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Service) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InternalPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.InternalPort))
	}
	if m.ExternalPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ExternalPort))
	}
	if len(m.IP) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.IP)))
		i += copy(dAtA[i:], m.IP)
	}
	return i, nil
}

func (m *AtomInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtomInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Repo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Repo)))
		i += copy(dAtA[i:], m.Repo)
	}
	if len(m.Branch) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Branch)))
		i += copy(dAtA[i:], m.Branch)
	}
	if len(m.Commit) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Commit)))
		i += copy(dAtA[i:], m.Commit)
	}
	if len(m.Glob) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Glob)))
		i += copy(dAtA[i:], m.Glob)
	}
	if m.Lazy {
		dAtA[i] = 0x30
		i++
		if m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EmptyFiles {
		dAtA[i] = 0x40
		i++
		if m.EmptyFiles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CronInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Repo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Repo)))
		i += copy(dAtA[i:], m.Repo)
	}
	if len(m.Commit) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Commit)))
		i += copy(dAtA[i:], m.Commit)
	}
	if len(m.Spec) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Spec)))
		i += copy(dAtA[i:], m.Spec)
	}
	if m.Start != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Start.Size()))
		n3, err := m.Start.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *GitInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GitInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.URL) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.URL)))
		i += copy(dAtA[i:], m.URL)
	}
	if len(m.Branch) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Branch)))
		i += copy(dAtA[i:], m.Branch)
	}
	if len(m.Commit) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Commit)))
		i += copy(dAtA[i:], m.Commit)
	}
	return i, nil
}

func (m *Input) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Input) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Atom != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Atom.Size()))
		n4, err := m.Atom.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Cross) > 0 {
		for _, msg := range m.Cross {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Union) > 0 {
		for _, msg := range m.Union {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Cron != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Cron.Size()))
		n5, err := m.Cron.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Git != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Git.Size()))
		n6, err := m.Git.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *JobInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Commit != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Commit.Size()))
		n7, err := m.Commit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Glob) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Glob)))
		i += copy(dAtA[i:], m.Glob)
	}
	if m.Lazy {
		dAtA[i] = 0x18
		i++
		if m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *ParallelismSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParallelismSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constant != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Constant))
	}
	if m.Coefficient != 0 {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Coefficient))))
		i += 8
	}
	return i, nil
}

func (m *InputFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	return i, nil
}

func (m *Datum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Datum) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.Job != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n8, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *DatumInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatumInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Datum != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Datum.Size()))
		n9, err := m.Datum.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Stats.Size()))
		n10, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.PfsState != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.PfsState.Size()))
		n11, err := m.PfsState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Aggregate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Count))
	}
	if m.Mean != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mean))))
		i += 8
	}
	if m.Stddev != 0 {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Stddev))))
		i += 8
	}
	if m.FifthPercentile != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FifthPercentile))))
		i += 8
	}
	if m.NinetyFifthPercentile != 0 {
		dAtA[i] = 0x29
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.NinetyFifthPercentile))))
		i += 8
	}
	return i, nil
}

func (m *ProcessStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DownloadTime != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DownloadTime.Size()))
		n12, err := m.DownloadTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.ProcessTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ProcessTime.Size()))
		n13, err := m.ProcessTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.UploadTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.UploadTime.Size()))
		n14, err := m.UploadTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.DownloadBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DownloadBytes))
	}
	if m.UploadBytes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.UploadBytes))
	}
	return i, nil
}

func (m *AggregateProcessStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregateProcessStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DownloadTime != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DownloadTime.Size()))
		n15, err := m.DownloadTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.ProcessTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ProcessTime.Size()))
		n16, err := m.ProcessTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.UploadTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.UploadTime.Size()))
		n17, err := m.UploadTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.DownloadBytes != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DownloadBytes.Size()))
		n18, err := m.DownloadBytes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.UploadBytes != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.UploadBytes.Size()))
		n19, err := m.UploadBytes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *WorkerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.WorkerID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.WorkerID)))
		i += copy(dAtA[i:], m.WorkerID)
	}
	if len(m.JobID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.JobID)))
		i += copy(dAtA[i:], m.JobID)
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Started != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Started.Size()))
		n20, err := m.Started.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Stats.Size()))
		n21, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.QueueSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.QueueSize))
	}
	return i, nil
}

func (m *ResourceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cpu != 0 {
		dAtA[i] = 0xd
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Cpu))))
		i += 4
	}
	if len(m.Memory) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Memory)))
		i += copy(dAtA[i:], m.Memory)
	}
	if m.Gpu != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Gpu))
	}
	return i, nil
}

func (m *EtcdJobInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EtcdJobInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n22, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Pipeline != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n23, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.OutputCommit != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputCommit.Size()))
		n24, err := m.OutputCommit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Restart != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Restart))
	}
	if m.DataProcessed != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataProcessed))
	}
	if m.DataSkipped != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataSkipped))
	}
	if m.DataTotal != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataTotal))
	}
	if m.DataFailed != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataFailed))
	}
	if m.Stats != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Stats.Size()))
		n25, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.StatsCommit != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.StatsCommit.Size()))
		n26, err := m.StatsCommit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.State != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	return i, nil
}

func (m *JobInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n27, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Transform != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Transform.Size()))
		n28, err := m.Transform.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Pipeline != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n29, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.ParentJob != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ParentJob.Size()))
		n30, err := m.ParentJob.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Started != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Started.Size()))
		n31, err := m.Started.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Finished != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Finished.Size()))
		n32, err := m.Finished.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.OutputCommit != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputCommit.Size()))
		n33, err := m.OutputCommit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.State != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	if m.ParallelismSpec != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ParallelismSpec.Size()))
		n34, err := m.ParallelismSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.PipelineVersion != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.PipelineVersion))
	}
	if m.Service != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Service.Size()))
		n35, err := m.Service.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.Egress != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Egress.Size()))
		n36, err := m.Egress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if len(m.OutputBranch) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.OutputBranch)))
		i += copy(dAtA[i:], m.OutputBranch)
	}
	if m.OutputRepo != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputRepo.Size()))
		n37, err := m.OutputRepo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.Restart != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Restart))
	}
	if m.DataProcessed != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataProcessed))
	}
	if m.DataTotal != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataTotal))
	}
	if len(m.WorkerStatus) > 0 {
		for _, msg := range m.WorkerStatus {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ResourceRequests != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceRequests.Size()))
		n38, err := m.ResourceRequests.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Input != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Input.Size()))
		n39, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.NewBranch != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.NewBranch.Size()))
		n40, err := m.NewBranch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.Incremental {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		if m.Incremental {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StatsCommit != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.StatsCommit.Size()))
		n41, err := m.StatsCommit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.DataSkipped != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataSkipped))
	}
	if m.Stats != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Stats.Size()))
		n42, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.EnableStats {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		if m.EnableStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Salt) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Salt)))
		i += copy(dAtA[i:], m.Salt)
	}
	if m.Batch {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		if m.Batch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.ResourceLimits != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceLimits.Size()))
		n43, err := m.ResourceLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.ChunkSpec != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ChunkSpec.Size()))
		n44, err := m.ChunkSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.DatumTimeout != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DatumTimeout.Size()))
		n45, err := m.DatumTimeout.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.JobTimeout != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.JobTimeout.Size()))
		n46, err := m.JobTimeout.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.DataFailed != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataFailed))
	}
	return i, nil
}

func (m *Worker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Worker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	return i, nil
}

func (m *JobInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.JobInfo) > 0 {
		for _, msg := range m.JobInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Pipeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pipeline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *PipelineInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Repo.Size()))
		n47, err := m.Repo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if len(m.Branch) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Branch)))
		i += copy(dAtA[i:], m.Branch)
	}
	if len(m.Glob) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Glob)))
		i += copy(dAtA[i:], m.Glob)
	}
	if m.Lazy {
		dAtA[i] = 0x20
		i++
		if m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.From != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.From.Size()))
		n48, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}

func (m *EtcdPipelineInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EtcdPipelineInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	if m.SpecCommit != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.SpecCommit.Size()))
		n49, err := m.SpecCommit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if len(m.JobCounts) > 0 {
		for k, _ := range m.JobCounts {
			dAtA[i] = 0x1a
			i++
			v := m.JobCounts[k]
			mapSize := 1 + sovPps(uint64(k)) + 1 + sovPps(uint64(v))
			i = encodeVarintPps(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintPps(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintPps(dAtA, i, uint64(v))
		}
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.AuthToken) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.AuthToken)))
		i += copy(dAtA[i:], m.AuthToken)
	}
	return i, nil
}

func (m *PipelineInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n50, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.Transform != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Transform.Size()))
		n51, err := m.Transform.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.CreatedAt != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.CreatedAt.Size()))
		n52, err := m.CreatedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.State != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	if len(m.RecentError) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.RecentError)))
		i += copy(dAtA[i:], m.RecentError)
	}
	if len(m.JobCounts) > 0 {
		for k, _ := range m.JobCounts {
			dAtA[i] = 0x4a
			i++
			v := m.JobCounts[k]
			mapSize := 1 + sovPps(uint64(k)) + 1 + sovPps(uint64(v))
			i = encodeVarintPps(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintPps(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintPps(dAtA, i, uint64(v))
		}
	}
	if m.ParallelismSpec != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ParallelismSpec.Size()))
		n53, err := m.ParallelismSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.Version != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Version))
	}
	if m.Egress != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Egress.Size()))
		n54, err := m.Egress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if len(m.OutputBranch) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.OutputBranch)))
		i += copy(dAtA[i:], m.OutputBranch)
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.ScaleDownThreshold != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ScaleDownThreshold.Size()))
		n55, err := m.ScaleDownThreshold.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.ResourceRequests != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceRequests.Size()))
		n56, err := m.ResourceRequests.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.Input != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Input.Size()))
		n57, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Incremental {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.Incremental {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CacheSize) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.CacheSize)))
		i += copy(dAtA[i:], m.CacheSize)
	}
	if m.EnableStats {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.EnableStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Salt) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Salt)))
		i += copy(dAtA[i:], m.Salt)
	}
	if m.Batch {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		if m.Batch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.MaxQueueSize != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.MaxQueueSize))
	}
	if m.Service != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Service.Size()))
		n58, err := m.Service.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.ResourceLimits != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceLimits.Size()))
		n59, err := m.ResourceLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if m.ChunkSpec != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ChunkSpec.Size()))
		n60, err := m.ChunkSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.DatumTimeout != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DatumTimeout.Size()))
		n61, err := m.DatumTimeout.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if m.JobTimeout != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.JobTimeout.Size()))
		n62, err := m.JobTimeout.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if len(m.GithookURL) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.GithookURL)))
		i += copy(dAtA[i:], m.GithookURL)
	}
	if m.SpecCommit != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.SpecCommit.Size()))
		n63, err := m.SpecCommit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	return i, nil
}

func (m *PipelineInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PipelineInfo) > 0 {
		for _, msg := range m.PipelineInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n64, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.OutputCommit != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputCommit.Size()))
		n65, err := m.OutputCommit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	return i, nil
}

func (m *InspectJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n66, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.BlockState {
		dAtA[i] = 0x10
		i++
		if m.BlockState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ListJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n67, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if len(m.InputCommit) > 0 {
		for _, msg := range m.InputCommit {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.OutputCommit != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputCommit.Size()))
		n68, err := m.OutputCommit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}

func (m *FlushJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlushJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for _, msg := range m.Commits {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ToPipelines) > 0 {
		for _, msg := range m.ToPipelines {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DeleteJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n69, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	return i, nil
}

func (m *StopJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n70, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	return i, nil
}

func (m *GetLogsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLogsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n71, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if m.Pipeline != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n72, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if len(m.DataFilters) > 0 {
		for _, s := range m.DataFilters {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Master {
		dAtA[i] = 0x28
		i++
		if m.Master {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Datum != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Datum.Size()))
		n73, err := m.Datum.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	if m.Follow {
		dAtA[i] = 0x38
		i++
		if m.Follow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Tail != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Tail))
	}
	return i, nil
}

func (m *LogMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PipelineName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.PipelineName)))
		i += copy(dAtA[i:], m.PipelineName)
	}
	if len(m.JobID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.JobID)))
		i += copy(dAtA[i:], m.JobID)
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ts != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Ts.Size()))
		n74, err := m.Ts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.WorkerID) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.WorkerID)))
		i += copy(dAtA[i:], m.WorkerID)
	}
	if m.User {
		dAtA[i] = 0x40
		i++
		if m.User {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.DatumID) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.DatumID)))
		i += copy(dAtA[i:], m.DatumID)
	}
	if m.Master {
		dAtA[i] = 0x50
		i++
		if m.Master {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RestartDatumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestartDatumRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n75, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if len(m.DataFilters) > 0 {
		for _, s := range m.DataFilters {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *InspectDatumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectDatumRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Datum != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Datum.Size()))
		n76, err := m.Datum.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	return i, nil
}

func (m *ListDatumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDatumRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n77, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.PageSize))
	}
	if m.Page != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *ListDatumResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDatumResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DatumInfos) > 0 {
		for _, msg := range m.DatumInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalPages != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.TotalPages))
	}
	if m.Page != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *ListDatumStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDatumStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DatumInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DatumInfo.Size()))
		n78, err := m.DatumInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	if m.TotalPages != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.TotalPages))
	}
	if m.Page != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *ChunkSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChunkSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Number))
	}
	if m.SizeBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.SizeBytes))
	}
	return i, nil
}

func (m *CreatePipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n79, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	if m.Transform != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Transform.Size()))
		n80, err := m.Transform.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	if m.Update {
		dAtA[i] = 0x28
		i++
		if m.Update {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ParallelismSpec != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ParallelismSpec.Size()))
		n81, err := m.ParallelismSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	if m.Egress != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Egress.Size()))
		n82, err := m.Egress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	if len(m.OutputBranch) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.OutputBranch)))
		i += copy(dAtA[i:], m.OutputBranch)
	}
	if m.ScaleDownThreshold != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ScaleDownThreshold.Size()))
		n83, err := m.ScaleDownThreshold.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	if m.ResourceRequests != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceRequests.Size()))
		n84, err := m.ResourceRequests.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	if m.Input != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Input.Size()))
		n85, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Incremental {
		dAtA[i] = 0x78
		i++
		if m.Incremental {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CacheSize) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.CacheSize)))
		i += copy(dAtA[i:], m.CacheSize)
	}
	if m.EnableStats {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.EnableStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Reprocess {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.Reprocess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Batch {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.Batch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxQueueSize != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.MaxQueueSize))
	}
	if m.Service != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Service.Size()))
		n86, err := m.Service.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	if m.ResourceLimits != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceLimits.Size()))
		n87, err := m.ResourceLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	if m.ChunkSpec != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ChunkSpec.Size()))
		n88, err := m.ChunkSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	if m.DatumTimeout != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DatumTimeout.Size()))
		n89, err := m.DatumTimeout.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	if m.JobTimeout != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.JobTimeout.Size()))
		n90, err := m.JobTimeout.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	if len(m.Salt) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Salt)))
		i += copy(dAtA[i:], m.Salt)
	}
	return i, nil
}

func (m *InspectPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n91, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	return i, nil
}

func (m *ListPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeletePipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n92, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	if m.All {
		dAtA[i] = 0x20
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StartPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n93, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	return i, nil
}

func (m *StopPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n94, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n94
	}
	return i, nil
}

func (m *RerunPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RerunPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n95, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n95
	}
	if len(m.Exclude) > 0 {
		for _, msg := range m.Exclude {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Include) > 0 {
		for _, msg := range m.Include {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GarbageCollectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GarbageCollectRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GarbageCollectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GarbageCollectResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ActivateAuthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateAuthRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ActivateAuthResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateAuthResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintPps(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Secret) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.MountPath)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.EnvVar)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *Transform) Size() (n int) {
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Cmd) > 0 {
		for _, s := range m.Cmd {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPps(uint64(len(k))) + 1 + len(v) + sovPps(uint64(len(v)))
			n += mapEntrySize + 1 + sovPps(uint64(mapEntrySize))
		}
	}
	if len(m.Secrets) > 0 {
		for _, e := range m.Secrets {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Stdin) > 0 {
		for _, s := range m.Stdin {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.AcceptReturnCode) > 0 {
		l = 0
		for _, e := range m.AcceptReturnCode {
			l += sovPps(uint64(e))
		}
		n += 1 + sovPps(uint64(l)) + l
	}
	if m.Debug {
		n += 2
	}
	if len(m.ImagePullSecrets) > 0 {
		for _, s := range m.ImagePullSecrets {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	return n
}

func (m *Egress) Size() (n int) {
	var l int
	_ = l
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *Job) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *Service) Size() (n int) {
	var l int
	_ = l
	if m.InternalPort != 0 {
		n += 1 + sovPps(uint64(m.InternalPort))
	}
	if m.ExternalPort != 0 {
		n += 1 + sovPps(uint64(m.ExternalPort))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *AtomInput) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Glob)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Lazy {
		n += 2
	}
	if m.EmptyFiles {
		n += 2
	}
	return n
}

func (m *CronInput) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Spec)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *GitInput) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *Input) Size() (n int) {
	var l int
	_ = l
	if m.Atom != nil {
		l = m.Atom.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Cross) > 0 {
		for _, e := range m.Cross {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Union) > 0 {
		for _, e := range m.Union {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.Cron != nil {
		l = m.Cron.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Git != nil {
		l = m.Git.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *JobInput) Size() (n int) {
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Glob)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Lazy {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *ParallelismSpec) Size() (n int) {
	var l int
	_ = l
	if m.Constant != 0 {
		n += 1 + sovPps(uint64(m.Constant))
	}
	if m.Coefficient != 0 {
		n += 9
	}
	return n
}

func (m *InputFile) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *Datum) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *DatumInfo) Size() (n int) {
	var l int
	_ = l
	if m.Datum != nil {
		l = m.Datum.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.PfsState != nil {
		l = m.PfsState.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	return n
}

func (m *Aggregate) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovPps(uint64(m.Count))
	}
	if m.Mean != 0 {
		n += 9
	}
	if m.Stddev != 0 {
		n += 9
	}
	if m.FifthPercentile != 0 {
		n += 9
	}
	if m.NinetyFifthPercentile != 0 {
		n += 9
	}
	return n
}

func (m *ProcessStats) Size() (n int) {
	var l int
	_ = l
	if m.DownloadTime != nil {
		l = m.DownloadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ProcessTime != nil {
		l = m.ProcessTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.UploadTime != nil {
		l = m.UploadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.DownloadBytes != 0 {
		n += 1 + sovPps(uint64(m.DownloadBytes))
	}
	if m.UploadBytes != 0 {
		n += 1 + sovPps(uint64(m.UploadBytes))
	}
	return n
}

func (m *AggregateProcessStats) Size() (n int) {
	var l int
	_ = l
	if m.DownloadTime != nil {
		l = m.DownloadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ProcessTime != nil {
		l = m.ProcessTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.UploadTime != nil {
		l = m.UploadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.DownloadBytes != nil {
		l = m.DownloadBytes.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.UploadBytes != nil {
		l = m.UploadBytes.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *WorkerStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.WorkerID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.JobID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.QueueSize != 0 {
		n += 1 + sovPps(uint64(m.QueueSize))
	}
	return n
}

func (m *ResourceSpec) Size() (n int) {
	var l int
	_ = l
	if m.Cpu != 0 {
		n += 5
	}
	l = len(m.Memory)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Gpu != 0 {
		n += 1 + sovPps(uint64(m.Gpu))
	}
	return n
}

func (m *EtcdJobInfo) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.OutputCommit != nil {
		l = m.OutputCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Restart != 0 {
		n += 1 + sovPps(uint64(m.Restart))
	}
	if m.DataProcessed != 0 {
		n += 1 + sovPps(uint64(m.DataProcessed))
	}
	if m.DataSkipped != 0 {
		n += 1 + sovPps(uint64(m.DataSkipped))
	}
	if m.DataTotal != 0 {
		n += 1 + sovPps(uint64(m.DataTotal))
	}
	if m.DataFailed != 0 {
		n += 1 + sovPps(uint64(m.DataFailed))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.StatsCommit != nil {
		l = m.StatsCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *JobInfo) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ParentJob != nil {
		l = m.ParentJob.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.OutputCommit != nil {
		l = m.OutputCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	if m.ParallelismSpec != nil {
		l = m.ParallelismSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.PipelineVersion != 0 {
		n += 1 + sovPps(uint64(m.PipelineVersion))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.OutputBranch)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.OutputRepo != nil {
		l = m.OutputRepo.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Restart != 0 {
		n += 2 + sovPps(uint64(m.Restart))
	}
	if m.DataProcessed != 0 {
		n += 2 + sovPps(uint64(m.DataProcessed))
	}
	if m.DataTotal != 0 {
		n += 2 + sovPps(uint64(m.DataTotal))
	}
	if len(m.WorkerStatus) > 0 {
		for _, e := range m.WorkerStatus {
			l = e.Size()
			n += 2 + l + sovPps(uint64(l))
		}
	}
	if m.ResourceRequests != nil {
		l = m.ResourceRequests.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.NewBranch != nil {
		l = m.NewBranch.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Incremental {
		n += 3
	}
	if m.StatsCommit != nil {
		l = m.StatsCommit.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DataSkipped != 0 {
		n += 2 + sovPps(uint64(m.DataSkipped))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.EnableStats {
		n += 3
	}
	l = len(m.Salt)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Batch {
		n += 3
	}
	l = len(m.Reason)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ResourceLimits != nil {
		l = m.ResourceLimits.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ChunkSpec != nil {
		l = m.ChunkSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DatumTimeout != nil {
		l = m.DatumTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.JobTimeout != nil {
		l = m.JobTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DataFailed != 0 {
		n += 2 + sovPps(uint64(m.DataFailed))
	}
	return n
}

func (m *Worker) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	return n
}

func (m *JobInfos) Size() (n int) {
	var l int
	_ = l
	if len(m.JobInfo) > 0 {
		for _, e := range m.JobInfo {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	return n
}

func (m *Pipeline) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *PipelineInput) Size() (n int) {
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Glob)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Lazy {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *EtcdPipelineInfo) Size() (n int) {
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	if m.SpecCommit != nil {
		l = m.SpecCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.JobCounts) > 0 {
		for k, v := range m.JobCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + sovPps(uint64(k)) + 1 + sovPps(uint64(v))
			n += mapEntrySize + 1 + sovPps(uint64(mapEntrySize))
		}
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.AuthToken)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *PipelineInfo) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	l = len(m.RecentError)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.JobCounts) > 0 {
		for k, v := range m.JobCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + sovPps(uint64(k)) + 1 + sovPps(uint64(v))
			n += mapEntrySize + 1 + sovPps(uint64(mapEntrySize))
		}
	}
	if m.ParallelismSpec != nil {
		l = m.ParallelismSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovPps(uint64(m.Version))
	}
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.OutputBranch)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ScaleDownThreshold != nil {
		l = m.ScaleDownThreshold.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ResourceRequests != nil {
		l = m.ResourceRequests.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Incremental {
		n += 3
	}
	l = len(m.CacheSize)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.EnableStats {
		n += 3
	}
	l = len(m.Salt)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Batch {
		n += 3
	}
	l = len(m.Reason)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.MaxQueueSize != 0 {
		n += 2 + sovPps(uint64(m.MaxQueueSize))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ResourceLimits != nil {
		l = m.ResourceLimits.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ChunkSpec != nil {
		l = m.ChunkSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DatumTimeout != nil {
		l = m.DatumTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.JobTimeout != nil {
		l = m.JobTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.GithookURL)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.SpecCommit != nil {
		l = m.SpecCommit.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	return n
}

func (m *PipelineInfos) Size() (n int) {
	var l int
	_ = l
	if len(m.PipelineInfo) > 0 {
		for _, e := range m.PipelineInfo {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	return n
}

func (m *CreateJobRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.OutputCommit != nil {
		l = m.OutputCommit.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	return n
}

func (m *InspectJobRequest) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.BlockState {
		n += 2
	}
	return n
}

func (m *ListJobRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.InputCommit) > 0 {
		for _, e := range m.InputCommit {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.OutputCommit != nil {
		l = m.OutputCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *FlushJobRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for _, e := range m.Commits {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.ToPipelines) > 0 {
		for _, e := range m.ToPipelines {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	return n
}

func (m *DeleteJobRequest) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *StopJobRequest) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *GetLogsRequest) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.DataFilters) > 0 {
		for _, s := range m.DataFilters {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.Master {
		n += 2
	}
	if m.Datum != nil {
		l = m.Datum.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Follow {
		n += 2
	}
	if m.Tail != 0 {
		n += 1 + sovPps(uint64(m.Tail))
	}
	return n
}

func (m *LogMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.PipelineName)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.JobID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.Ts != nil {
		l = m.Ts.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.WorkerID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.User {
		n += 2
	}
	l = len(m.DatumID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Master {
		n += 2
	}
	return n
}

func (m *RestartDatumRequest) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.DataFilters) > 0 {
		for _, s := range m.DataFilters {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	return n
}

func (m *InspectDatumRequest) Size() (n int) {
	var l int
	_ = l
	if m.Datum != nil {
		l = m.Datum.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *ListDatumRequest) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovPps(uint64(m.PageSize))
	}
	if m.Page != 0 {
		n += 1 + sovPps(uint64(m.Page))
	}
	return n
}

func (m *ListDatumResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.DatumInfos) > 0 {
		for _, e := range m.DatumInfos {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.TotalPages != 0 {
		n += 1 + sovPps(uint64(m.TotalPages))
	}
	if m.Page != 0 {
		n += 1 + sovPps(uint64(m.Page))
	}
	return n
}

func (m *ListDatumStreamResponse) Size() (n int) {
	var l int
	_ = l
	if m.DatumInfo != nil {
		l = m.DatumInfo.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.TotalPages != 0 {
		n += 1 + sovPps(uint64(m.TotalPages))
	}
	if m.Page != 0 {
		n += 1 + sovPps(uint64(m.Page))
	}
	return n
}

func (m *ChunkSpec) Size() (n int) {
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovPps(uint64(m.Number))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPps(uint64(m.SizeBytes))
	}
	return n
}

func (m *CreatePipelineRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Update {
		n += 2
	}
	if m.ParallelismSpec != nil {
		l = m.ParallelismSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.OutputBranch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ScaleDownThreshold != nil {
		l = m.ScaleDownThreshold.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ResourceRequests != nil {
		l = m.ResourceRequests.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Incremental {
		n += 2
	}
	l = len(m.CacheSize)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.EnableStats {
		n += 3
	}
	if m.Reprocess {
		n += 3
	}
	if m.Batch {
		n += 3
	}
	if m.MaxQueueSize != 0 {
		n += 2 + sovPps(uint64(m.MaxQueueSize))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ResourceLimits != nil {
		l = m.ResourceLimits.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ChunkSpec != nil {
		l = m.ChunkSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DatumTimeout != nil {
		l = m.DatumTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.JobTimeout != nil {
		l = m.JobTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	return n
}

func (m *InspectPipelineRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *ListPipelineRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeletePipelineRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.All {
		n += 2
	}
	return n
}

func (m *StartPipelineRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *StopPipelineRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *RerunPipelineRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Exclude) > 0 {
		for _, e := range m.Exclude {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Include) > 0 {
		for _, e := range m.Include {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	return n
}

func (m *GarbageCollectRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GarbageCollectResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ActivateAuthRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ActivateAuthResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovPps(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPps(x uint64) (n int) {
	return sovPps(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Secret) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Secret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Secret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvVar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = append(m.Cmd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secrets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secrets = append(m.Secrets, &Secret{})
			if err := m.Secrets[len(m.Secrets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stdin = append(m.Stdin, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AcceptReturnCode = append(m.AcceptReturnCode, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPps
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AcceptReturnCode = append(m.AcceptReturnCode, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptReturnCode", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Debug = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullSecrets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullSecrets = append(m.ImagePullSecrets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Egress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Egress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Egress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPort", wireType)
			}
			m.InternalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalPort", wireType)
			}
			m.ExternalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtomInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtomInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtomInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Glob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lazy = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmptyFiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmptyFiles = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &google_protobuf1.Timestamp{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Input) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Input: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Input: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Atom == nil {
				m.Atom = &AtomInput{}
			}
			if err := m.Atom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cross", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cross = append(m.Cross, &Input{})
			if err := m.Cross[len(m.Cross)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Union", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Union = append(m.Union, &Input{})
			if err := m.Union[len(m.Union)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cron", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cron == nil {
				m.Cron = &CronInput{}
			}
			if err := m.Cron.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Git", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Git == nil {
				m.Git = &GitInput{}
			}
			if err := m.Git.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &pfs.Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Glob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lazy = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParallelismSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParallelismSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParallelismSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constant", wireType)
			}
			m.Constant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constant |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coefficient", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Coefficient = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Datum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Datum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Datum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatumInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatumInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatumInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datum == nil {
				m.Datum = &Datum{}
			}
			if err := m.Datum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (DatumState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ProcessStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PfsState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PfsState == nil {
				m.PfsState = &pfs.File{}
			}
			if err := m.PfsState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &pfs.FileInfo{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aggregate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mean", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mean = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stddev", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Stddev = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FifthPercentile", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FifthPercentile = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NinetyFifthPercentile", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.NinetyFifthPercentile = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadTime == nil {
				m.DownloadTime = &google_protobuf2.Duration{}
			}
			if err := m.DownloadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProcessTime == nil {
				m.ProcessTime = &google_protobuf2.Duration{}
			}
			if err := m.ProcessTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadTime == nil {
				m.UploadTime = &google_protobuf2.Duration{}
			}
			if err := m.UploadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadBytes", wireType)
			}
			m.DownloadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadBytes", wireType)
			}
			m.UploadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregateProcessStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregateProcessStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregateProcessStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadTime == nil {
				m.DownloadTime = &Aggregate{}
			}
			if err := m.DownloadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProcessTime == nil {
				m.ProcessTime = &Aggregate{}
			}
			if err := m.ProcessTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadTime == nil {
				m.UploadTime = &Aggregate{}
			}
			if err := m.UploadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadBytes == nil {
				m.DownloadBytes = &Aggregate{}
			}
			if err := m.DownloadBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadBytes == nil {
				m.UploadBytes = &Aggregate{}
			}
			if err := m.UploadBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &InputFile{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &google_protobuf1.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ProcessStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueSize", wireType)
			}
			m.QueueSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Cpu = float32(math.Float32frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpu", wireType)
			}
			m.Gpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gpu |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EtcdJobInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EtcdJobInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EtcdJobInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCommit == nil {
				m.OutputCommit = &pfs.Commit{}
			}
			if err := m.OutputCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restart", wireType)
			}
			m.Restart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Restart |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProcessed", wireType)
			}
			m.DataProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataProcessed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSkipped", wireType)
			}
			m.DataSkipped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSkipped |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTotal", wireType)
			}
			m.DataTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataTotal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFailed", wireType)
			}
			m.DataFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataFailed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ProcessStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StatsCommit == nil {
				m.StatsCommit = &pfs.Commit{}
			}
			if err := m.StatsCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (JobState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transform == nil {
				m.Transform = &Transform{}
			}
			if err := m.Transform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentJob == nil {
				m.ParentJob = &Job{}
			}
			if err := m.ParentJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &google_protobuf1.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Finished == nil {
				m.Finished = &google_protobuf1.Timestamp{}
			}
			if err := m.Finished.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCommit == nil {
				m.OutputCommit = &pfs.Commit{}
			}
			if err := m.OutputCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (JobState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelismSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelismSpec == nil {
				m.ParallelismSpec = &ParallelismSpec{}
			}
			if err := m.ParallelismSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineVersion", wireType)
			}
			m.PipelineVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PipelineVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &Service{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Egress == nil {
				m.Egress = &Egress{}
			}
			if err := m.Egress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputBranch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputRepo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputRepo == nil {
				m.OutputRepo = &pfs.Repo{}
			}
			if err := m.OutputRepo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restart", wireType)
			}
			m.Restart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Restart |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProcessed", wireType)
			}
			m.DataProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataProcessed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTotal", wireType)
			}
			m.DataTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataTotal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerStatus = append(m.WorkerStatus, &WorkerStatus{})
			if err := m.WorkerStatus[len(m.WorkerStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceRequests == nil {
				m.ResourceRequests = &ResourceSpec{}
			}
			if err := m.ResourceRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewBranch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewBranch == nil {
				m.NewBranch = &pfs.BranchInfo{}
			}
			if err := m.NewBranch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incremental", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Incremental = bool(v != 0)
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StatsCommit == nil {
				m.StatsCommit = &pfs.Commit{}
			}
			if err := m.StatsCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSkipped", wireType)
			}
			m.DataSkipped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSkipped |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ProcessStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStats = bool(v != 0)
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Batch = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLimits == nil {
				m.ResourceLimits = &ResourceSpec{}
			}
			if err := m.ResourceLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChunkSpec == nil {
				m.ChunkSpec = &ChunkSpec{}
			}
			if err := m.ChunkSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumTimeout == nil {
				m.DatumTimeout = &google_protobuf2.Duration{}
			}
			if err := m.DatumTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobTimeout == nil {
				m.JobTimeout = &google_protobuf2.Duration{}
			}
			if err := m.JobTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFailed", wireType)
			}
			m.DataFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataFailed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Worker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Worker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Worker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (WorkerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobInfo = append(m.JobInfo, &JobInfo{})
			if err := m.JobInfo[len(m.JobInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &pfs.Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Glob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lazy = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &pfs.Commit{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EtcdPipelineInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EtcdPipelineInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EtcdPipelineInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (PipelineState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpecCommit == nil {
				m.SpecCommit = &pfs.Commit{}
			}
			if err := m.SpecCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobCounts == nil {
				m.JobCounts = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JobCounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transform == nil {
				m.Transform = &Transform{}
			}
			if err := m.Transform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &google_protobuf1.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (PipelineState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecentError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecentError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobCounts == nil {
				m.JobCounts = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JobCounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelismSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelismSpec == nil {
				m.ParallelismSpec = &ParallelismSpec{}
			}
			if err := m.ParallelismSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Egress == nil {
				m.Egress = &Egress{}
			}
			if err := m.Egress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputBranch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleDownThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScaleDownThreshold == nil {
				m.ScaleDownThreshold = &google_protobuf2.Duration{}
			}
			if err := m.ScaleDownThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceRequests == nil {
				m.ResourceRequests = &ResourceSpec{}
			}
			if err := m.ResourceRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incremental", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Incremental = bool(v != 0)
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStats = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Batch = bool(v != 0)
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueueSize", wireType)
			}
			m.MaxQueueSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQueueSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &Service{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLimits == nil {
				m.ResourceLimits = &ResourceSpec{}
			}
			if err := m.ResourceLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChunkSpec == nil {
				m.ChunkSpec = &ChunkSpec{}
			}
			if err := m.ChunkSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumTimeout == nil {
				m.DatumTimeout = &google_protobuf2.Duration{}
			}
			if err := m.DatumTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobTimeout == nil {
				m.JobTimeout = &google_protobuf2.Duration{}
			}
			if err := m.JobTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GithookURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GithookURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpecCommit == nil {
				m.SpecCommit = &pfs.Commit{}
			}
			if err := m.SpecCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PipelineInfo = append(m.PipelineInfo, &PipelineInfo{})
			if err := m.PipelineInfo[len(m.PipelineInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCommit == nil {
				m.OutputCommit = &pfs.Commit{}
			}
			if err := m.OutputCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockState = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputCommit = append(m.InputCommit, &pfs.Commit{})
			if err := m.InputCommit[len(m.InputCommit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCommit == nil {
				m.OutputCommit = &pfs.Commit{}
			}
			if err := m.OutputCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlushJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlushJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlushJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commits = append(m.Commits, &pfs.Commit{})
			if err := m.Commits[len(m.Commits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToPipelines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToPipelines = append(m.ToPipelines, &Pipeline{})
			if err := m.ToPipelines[len(m.ToPipelines)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLogsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLogsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLogsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFilters = append(m.DataFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Master = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datum == nil {
				m.Datum = &Datum{}
			}
			if err := m.Datum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Follow = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tail", wireType)
			}
			m.Tail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tail |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PipelineName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &InputFile{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ts == nil {
				m.Ts = &google_protobuf1.Timestamp{}
			}
			if err := m.Ts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.User = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatumID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Master = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestartDatumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestartDatumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestartDatumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFilters = append(m.DataFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectDatumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectDatumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectDatumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datum == nil {
				m.Datum = &Datum{}
			}
			if err := m.Datum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDatumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDatumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDatumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDatumResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDatumResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDatumResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatumInfos = append(m.DatumInfos, &DatumInfo{})
			if err := m.DatumInfos[len(m.DatumInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPages", wireType)
			}
			m.TotalPages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPages |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDatumStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDatumStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDatumStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumInfo == nil {
				m.DatumInfo = &DatumInfo{}
			}
			if err := m.DatumInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPages", wireType)
			}
			m.TotalPages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPages |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChunkSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChunkSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChunkSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transform == nil {
				m.Transform = &Transform{}
			}
			if err := m.Transform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Update = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelismSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelismSpec == nil {
				m.ParallelismSpec = &ParallelismSpec{}
			}
			if err := m.ParallelismSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Egress == nil {
				m.Egress = &Egress{}
			}
			if err := m.Egress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputBranch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleDownThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScaleDownThreshold == nil {
				m.ScaleDownThreshold = &google_protobuf2.Duration{}
			}
			if err := m.ScaleDownThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceRequests == nil {
				m.ResourceRequests = &ResourceSpec{}
			}
			if err := m.ResourceRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incremental", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Incremental = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStats = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reprocess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reprocess = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Batch = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueueSize", wireType)
			}
			m.MaxQueueSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQueueSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &Service{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLimits == nil {
				m.ResourceLimits = &ResourceSpec{}
			}
			if err := m.ResourceLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChunkSpec == nil {
				m.ChunkSpec = &ChunkSpec{}
			}
			if err := m.ChunkSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumTimeout == nil {
				m.DatumTimeout = &google_protobuf2.Duration{}
			}
			if err := m.DatumTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobTimeout == nil {
				m.JobTimeout = &google_protobuf2.Duration{}
			}
			if err := m.JobTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RerunPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RerunPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RerunPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exclude = append(m.Exclude, &pfs.Commit{})
			if err := m.Exclude[len(m.Exclude)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Include", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Include = append(m.Include, &pfs.Commit{})
			if err := m.Include[len(m.Include)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GarbageCollectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GarbageCollectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GarbageCollectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GarbageCollectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GarbageCollectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GarbageCollectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateAuthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateAuthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateAuthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateAuthResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateAuthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateAuthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPps(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPps
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPps
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPps
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPps
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPps
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPps(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPps = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPps   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("client/pps/pps.proto", fileDescriptorPps) }

var fileDescriptorPps = []byte{
	// 3864 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x5a, 0x4f, 0x6f, 0xdb, 0xd8,
	0x76, 0xb7, 0x44, 0xca, 0x22, 0x8f, 0x64, 0x99, 0xbe, 0xfe, 0x27, 0x2b, 0x93, 0xd8, 0xe1, 0x4c,
	0x32, 0x49, 0x30, 0xcf, 0x99, 0xe7, 0xbc, 0xa6, 0xaf, 0xd3, 0xe9, 0xcc, 0xf3, 0xbf, 0x04, 0xd6,
	0xb8, 0x79, 0x2a, 0x6d, 0xbf, 0x2e, 0x55, 0x9a, 0xba, 0x92, 0x19, 0x53, 0x24, 0x1f, 0x49, 0x39,
	0xc9, 0x00, 0x05, 0xfa, 0x0d, 0x8a, 0x76, 0x55, 0x14, 0xe8, 0xaa, 0xfd, 0x00, 0x45, 0x51, 0xa0,
	0x9b, 0x2e, 0xba, 0x29, 0x30, 0xcb, 0xf6, 0x0b, 0x04, 0x85, 0x0b, 0x74, 0xd7, 0x75, 0x57, 0x05,
	0x8a, 0x7b, 0xee, 0x25, 0x45, 0x52, 0xb4, 0x14, 0x27, 0x5d, 0x18, 0xe0, 0x3d, 0xf7, 0xdc, 0x7f,
	0xe7, 0xdc, 0x73, 0x7e, 0xbf, 0x73, 0x65, 0x58, 0xb1, 0x1c, 0x9b, 0xba, 0xd1, 0x53, 0xdf, 0x0f,
	0xd9, 0xdf, 0xb6, 0x1f, 0x78, 0x91, 0x47, 0x24, 0xdf, 0x0f, 0x5b, 0x77, 0x06, 0x9e, 0x37, 0x70,
	0xe8, 0x53, 0x14, 0x9d, 0x8f, 0xfa, 0x4f, 0xe9, 0xd0, 0x8f, 0xde, 0x71, 0x8d, 0xd6, 0x66, 0xbe,
	0x33, 0xb2, 0x87, 0x34, 0x8c, 0xcc, 0xa1, 0x2f, 0x14, 0xee, 0xe5, 0x15, 0x7a, 0xa3, 0xc0, 0x8c,
	0x6c, 0xcf, 0x15, 0xfd, 0x2b, 0x03, 0x6f, 0xe0, 0xe1, 0xe7, 0x53, 0xf6, 0x15, 0x4b, 0xe3, 0xed,
	0xf4, 0x43, 0xf6, 0xc7, 0xa5, 0x7a, 0x1f, 0xe6, 0x4f, 0xa8, 0x15, 0xd0, 0x88, 0x10, 0x90, 0x5d,
	0x73, 0x48, 0x9b, 0xa5, 0xad, 0xd2, 0x23, 0xd5, 0xc0, 0x6f, 0x72, 0x17, 0x60, 0xe8, 0x8d, 0xdc,
	0xa8, 0xeb, 0x9b, 0xd1, 0x45, 0xb3, 0x8c, 0x3d, 0x2a, 0x4a, 0x3a, 0x66, 0x74, 0x41, 0xd6, 0xa1,
	0x4a, 0xdd, 0xab, 0xee, 0x95, 0x19, 0x34, 0x25, 0xec, 0x9b, 0xa7, 0xee, 0xd5, 0x6f, 0xcc, 0x80,
	0x68, 0x20, 0x5d, 0xd2, 0x77, 0x4d, 0x19, 0x85, 0xec, 0x53, 0xff, 0xd7, 0x32, 0xa8, 0xa7, 0x81,
	0xe9, 0x86, 0x7d, 0x2f, 0x18, 0x92, 0x15, 0xa8, 0xd8, 0x43, 0x73, 0x10, 0x2f, 0xc6, 0x1b, 0x6c,
	0x94, 0x35, 0xec, 0x35, 0xcb, 0x5b, 0x12, 0x1b, 0x65, 0x0d, 0x7b, 0xe4, 0x31, 0x48, 0xd4, 0xbd,
	0x6a, 0x4a, 0x5b, 0xd2, 0xa3, 0xda, 0xce, 0xfa, 0x36, 0xb3, 0x62, 0x32, 0xc9, 0xf6, 0xa1, 0x7b,
	0x75, 0xe8, 0x46, 0xc1, 0x3b, 0x83, 0xe9, 0x90, 0x07, 0x50, 0x0d, 0xf1, 0x20, 0x61, 0x53, 0x46,
	0xf5, 0x1a, 0xaa, 0xf3, 0xc3, 0x19, 0x71, 0x1f, 0x5b, 0x39, 0x8c, 0x7a, 0xb6, 0xdb, 0xac, 0xe0,
	0x2a, 0xbc, 0x41, 0xbe, 0x02, 0x62, 0x5a, 0x16, 0xf5, 0xa3, 0x6e, 0x40, 0xa3, 0x51, 0xe0, 0x76,
	0x2d, 0xaf, 0x47, 0x9b, 0xf3, 0x5b, 0xd2, 0x23, 0xc9, 0xd0, 0x78, 0x8f, 0x81, 0x1d, 0xfb, 0x5e,
	0x8f, 0xb2, 0x39, 0x7a, 0xf4, 0x7c, 0x34, 0x68, 0x56, 0xb7, 0x4a, 0x8f, 0x14, 0x83, 0x37, 0xd8,
	0x1c, 0x78, 0x8c, 0xae, 0x3f, 0x72, 0x9c, 0x6e, 0xbc, 0x17, 0x15, 0x97, 0xd1, 0xb0, 0xa7, 0x33,
	0x72, 0x1c, 0xbe, 0x9f, 0xb0, 0xf5, 0x1c, 0x94, 0x78, 0xff, 0xb1, 0xb5, 0x4a, 0x89, 0xb5, 0xd8,
	0x0a, 0x57, 0xa6, 0x33, 0xa2, 0xc2, 0xe4, 0xbc, 0xf1, 0x4d, 0xf9, 0x97, 0x25, 0xbd, 0x05, 0xf3,
	0x87, 0x83, 0x80, 0x86, 0x21, 0x1b, 0x75, 0x66, 0x1c, 0xc7, 0xa3, 0xce, 0x8c, 0x63, 0xfd, 0x2e,
	0x48, 0x6d, 0xef, 0x9c, 0xac, 0x41, 0xd9, 0xee, 0x71, 0xf9, 0xde, 0xfc, 0xf5, 0xfb, 0xcd, 0xf2,
	0xd1, 0x81, 0x51, 0xb6, 0x7b, 0xfa, 0x25, 0x54, 0x4f, 0x68, 0x70, 0x65, 0x5b, 0x94, 0x7c, 0x0e,
	0x0b, 0xb6, 0x1b, 0xd1, 0xc0, 0x35, 0x9d, 0xae, 0xef, 0x05, 0x11, 0x6a, 0x57, 0x8c, 0x7a, 0x2c,
	0xec, 0x78, 0x41, 0xc4, 0x94, 0xe8, 0xdb, 0xb4, 0x52, 0x99, 0x2b, 0xc5, 0x42, 0x54, 0x62, 0x8b,
	0xf9, 0xdc, 0xfb, 0x62, 0xb1, 0x8e, 0x51, 0xb6, 0x7d, 0xfd, 0x1f, 0x4a, 0xa0, 0xee, 0x46, 0xde,
	0xf0, 0xc8, 0xf5, 0x47, 0xc5, 0x77, 0x8b, 0x80, 0x1c, 0x50, 0xdf, 0x13, 0x47, 0xc4, 0x6f, 0xb2,
	0x06, 0xf3, 0xe7, 0x81, 0xe9, 0x5a, 0x17, 0xf1, 0x7d, 0xe2, 0x2d, 0x26, 0xb7, 0xbc, 0xe1, 0xd0,
	0x8e, 0xc4, 0x95, 0x12, 0x2d, 0x36, 0xc7, 0xc0, 0xf1, 0xce, 0x9b, 0x15, 0x3e, 0x07, 0xfb, 0x66,
	0x32, 0xc7, 0xfc, 0xf1, 0x5d, 0x73, 0x1e, 0x9d, 0x83, 0xdf, 0x64, 0x13, 0x6a, 0x18, 0x61, 0xdd,
	0xbe, 0xed, 0xd0, 0xb0, 0xa9, 0x60, 0x17, 0xa0, 0xe8, 0x05, 0x93, 0xb4, 0x65, 0xa5, 0xaa, 0x29,
	0xfa, 0x5f, 0x94, 0x40, 0xdd, 0x0f, 0x3c, 0xf7, 0xd6, 0x9b, 0x16, 0x9b, 0x93, 0xf2, 0x9b, 0x0b,
	0x7d, 0x6a, 0x89, 0x2d, 0xe3, 0x37, 0xf9, 0x9a, 0x5d, 0x3f, 0x33, 0x88, 0x70, 0xc7, 0xb5, 0x9d,
	0xd6, 0x36, 0x0f, 0xe5, 0xed, 0x38, 0x94, 0xb7, 0x4f, 0xe3, 0x58, 0x37, 0xb8, 0xa2, 0x6e, 0x83,
	0xf2, 0xd2, 0x8e, 0x6e, 0xde, 0xd1, 0x06, 0x48, 0xa3, 0xc0, 0xe1, 0x1b, 0xda, 0xab, 0x5e, 0xbf,
	0xdf, 0x64, 0x57, 0xc1, 0x60, 0xb2, 0xdb, 0x5a, 0x53, 0xff, 0xc7, 0x12, 0x54, 0xf8, 0x42, 0x3a,
	0xc8, 0x66, 0xe4, 0x0d, 0x71, 0xa1, 0xda, 0x4e, 0x03, 0x23, 0x29, 0xf1, 0xa6, 0x81, 0x7d, 0x64,
	0x0b, 0x2a, 0x56, 0xe0, 0x85, 0x21, 0xc6, 0x6b, 0x6d, 0x07, 0x50, 0x89, 0x2b, 0xf0, 0x0e, 0xa6,
	0x31, 0x72, 0x6d, 0xcf, 0x15, 0xf1, 0x9b, 0xd1, 0xc0, 0x0e, 0xb6, 0x8e, 0x15, 0x78, 0x2e, 0xee,
	0x23, 0x5e, 0x27, 0x71, 0x80, 0x81, 0x7d, 0x64, 0x13, 0xa4, 0x81, 0x1d, 0x1b, 0x6c, 0x01, 0x55,
	0x62, 0x83, 0x18, 0xac, 0x47, 0xbf, 0x04, 0xa5, 0xed, 0x9d, 0xf3, 0x8d, 0x7f, 0x9e, 0x1c, 0x8d,
	0x6f, 0xbd, 0xb6, 0xcd, 0x52, 0xdd, 0x3e, 0x8a, 0x26, 0x6e, 0x4d, 0xb9, 0xe0, 0xd6, 0x48, 0xa9,
	0x5b, 0x13, 0x9b, 0x5b, 0x1e, 0x9b, 0x5b, 0x3f, 0x83, 0xc5, 0x8e, 0x19, 0x98, 0x8e, 0x43, 0x1d,
	0x3b, 0x1c, 0x9e, 0x30, 0x9f, 0xb6, 0x40, 0xb1, 0x3c, 0x37, 0x8c, 0x4c, 0x97, 0x87, 0x88, 0x6c,
	0x24, 0x6d, 0xb2, 0x05, 0x35, 0xcb, 0xa3, 0xfd, 0xbe, 0x6d, 0xb1, 0xdc, 0x8b, 0xb3, 0x97, 0x8c,
	0xb4, 0xa8, 0x2d, 0x2b, 0x25, 0xad, 0xac, 0x3f, 0x03, 0x15, 0x0f, 0xc0, 0x6e, 0x23, 0x5b, 0x17,
	0xf3, 0xad, 0x58, 0x97, 0x7d, 0x33, 0xd9, 0x85, 0x19, 0x5e, 0xa0, 0x19, 0xea, 0x06, 0x7e, 0xeb,
	0xbf, 0x0f, 0x95, 0x03, 0x33, 0x1a, 0x0d, 0x6f, 0x8a, 0x78, 0xd2, 0x02, 0xe9, 0xb5, 0x38, 0x67,
	0x6d, 0x47, 0x41, 0xd3, 0xb5, 0xbd, 0x73, 0x83, 0x09, 0xf5, 0x9f, 0x4a, 0xa0, 0xe2, 0xe8, 0x23,
	0xb7, 0xef, 0x31, 0x57, 0xf5, 0x58, 0x43, 0x98, 0x8d, 0xbb, 0x0a, 0xbb, 0x0d, 0xde, 0x41, 0x1e,
	0xe0, 0xcd, 0x8d, 0x78, 0x4a, 0x6a, 0xec, 0x2c, 0x8e, 0x35, 0x4e, 0x98, 0xd8, 0xe0, 0xbd, 0xe4,
	0x4b, 0xae, 0x16, 0xe2, 0x51, 0x6b, 0x3b, 0x4b, 0xa8, 0xd6, 0x09, 0x3c, 0x8b, 0x86, 0x21, 0x53,
	0x0c, 0xb9, 0x62, 0x48, 0x1e, 0x82, 0xea, 0xf7, 0xc3, 0x2e, 0x9f, 0x93, 0xfb, 0x5f, 0x45, 0x67,
	0x31, 0x13, 0x18, 0x8a, 0xdf, 0x47, 0x75, 0x4a, 0xee, 0x83, 0xdc, 0x33, 0x23, 0x13, 0xf3, 0x35,
	0xfa, 0x5f, 0xa8, 0xb0, 0x6d, 0x1b, 0xd8, 0xa5, 0xff, 0x3d, 0xcb, 0x35, 0x83, 0x41, 0x40, 0x07,
	0x6c, 0xc0, 0x0a, 0x54, 0x2c, 0x86, 0x50, 0x78, 0x14, 0xc9, 0xe0, 0x0d, 0x66, 0xbf, 0x21, 0x35,
	0x5d, 0xdc, 0x7d, 0xc9, 0xc0, 0x6f, 0x16, 0x07, 0x61, 0xd4, 0xeb, 0xd1, 0x2b, 0xe1, 0x17, 0xd1,
	0x22, 0x8f, 0x41, 0xeb, 0xdb, 0xfd, 0xe8, 0xa2, 0xeb, 0xd3, 0xc0, 0xa2, 0x6e, 0x64, 0x3b, 0x7c,
	0x87, 0x25, 0x63, 0x11, 0xe5, 0x9d, 0x44, 0x4c, 0x9e, 0xc3, 0xba, 0x6b, 0xbb, 0x14, 0x33, 0x4b,
	0x6e, 0x44, 0x05, 0x47, 0xac, 0xf2, 0xee, 0x17, 0xd9, 0x71, 0xfa, 0x5f, 0x96, 0xa1, 0x9e, 0xb6,
	0x0a, 0xf9, 0x0e, 0x16, 0x7a, 0xde, 0x1b, 0xd7, 0xf1, 0xcc, 0x5e, 0x97, 0xe1, 0xbd, 0x70, 0xc4,
	0xc6, 0x44, 0x82, 0x38, 0x10, 0x58, 0x6f, 0xd4, 0x63, 0x7d, 0x96, 0x32, 0xc8, 0xb7, 0x50, 0xf7,
	0xf9, 0x7c, 0x7c, 0x78, 0x79, 0xd6, 0xf0, 0x9a, 0x50, 0xc7, 0xd1, 0xdf, 0x40, 0x6d, 0xe4, 0x8f,
	0xd7, 0x96, 0x66, 0x0d, 0x06, 0xae, 0x8d, 0x63, 0x1f, 0x40, 0x23, 0xd9, 0xf9, 0xf9, 0xbb, 0x88,
	0x86, 0x68, 0x2b, 0xd9, 0x48, 0xce, 0xb3, 0xc7, 0x84, 0xe4, 0x3e, 0xd4, 0xc5, 0x12, 0x5c, 0xa9,
	0x82, 0x4a, 0x62, 0x59, 0x54, 0xd1, 0xff, 0xba, 0x0c, 0xab, 0x89, 0x1f, 0x33, 0xd6, 0x79, 0x56,
	0x6c, 0x1d, 0x91, 0x98, 0xe2, 0x21, 0x39, 0x93, 0xfc, 0xbc, 0xd0, 0x24, 0xf9, 0x31, 0x19, 0x3b,
	0x3c, 0x2d, 0xb2, 0x43, 0x7e, 0x44, 0xfa, 0xf0, 0xbf, 0x53, 0x78, 0xf8, 0xc9, 0x31, 0x39, 0x63,
	0xfc, 0xbc, 0xc0, 0x18, 0x05, 0x5b, 0x4b, 0x1b, 0xe7, 0x7f, 0x4b, 0x50, 0xff, 0x63, 0x2f, 0xb8,
	0xa4, 0x01, 0x33, 0xc9, 0x28, 0x24, 0x8f, 0x41, 0x7d, 0x83, 0xed, 0x6e, 0x12, 0xfb, 0xf5, 0xeb,
	0xf7, 0x9b, 0x0a, 0x57, 0x3a, 0x3a, 0x30, 0x14, 0xde, 0x7d, 0xd4, 0x23, 0x5b, 0x30, 0xff, 0xda,
	0x3b, 0x67, 0x7a, 0x1c, 0x26, 0xd4, 0xeb, 0xf7, 0x9b, 0x15, 0x96, 0x33, 0x0f, 0x8c, 0xca, 0x6b,
	0xef, 0xfc, 0xa8, 0xc7, 0x12, 0x31, 0x46, 0x19, 0xcf, 0xd4, 0x8d, 0x71, 0xa6, 0xc6, 0x68, 0xc4,
	0x3e, 0xf2, 0x0b, 0xa8, 0x22, 0x24, 0xd1, 0x9e, 0x38, 0xe4, 0x34, 0xf4, 0x8a, 0x55, 0xc7, 0x09,
	0xa1, 0x32, 0x23, 0x21, 0xdc, 0x05, 0xf8, 0xed, 0x88, 0x8e, 0x68, 0x37, 0xb4, 0x7f, 0xa4, 0x88,
	0xde, 0x92, 0xa1, 0xa2, 0xe4, 0xc4, 0xfe, 0x91, 0xea, 0x6d, 0xa8, 0x1b, 0x34, 0xf4, 0x46, 0x81,
	0x45, 0x31, 0xeb, 0x32, 0xb2, 0xe8, 0x8f, 0xf0, 0xe0, 0x65, 0x83, 0x7d, 0xb2, 0x70, 0x1e, 0xd2,
	0xa1, 0x17, 0xbc, 0x13, 0x89, 0x5d, 0xb4, 0x98, 0xe6, 0xc0, 0x1f, 0xa1, 0x33, 0x25, 0x83, 0x7d,
	0xea, 0xff, 0x22, 0x41, 0xed, 0x30, 0xb2, 0x7a, 0x08, 0x1b, 0x7d, 0x2f, 0xce, 0x93, 0xa5, 0x82,
	0x3c, 0x49, 0x1e, 0x83, 0xe2, 0xdb, 0x3e, 0x75, 0x6c, 0x37, 0xbe, 0x41, 0x1c, 0x83, 0x3a, 0x42,
	0x68, 0x24, 0xdd, 0xe4, 0x6b, 0x58, 0xf0, 0x46, 0x91, 0x3f, 0x8a, 0xba, 0x29, 0x3e, 0x90, 0xc3,
	0xa0, 0x3a, 0xd7, 0xe0, 0x2d, 0xd2, 0x84, 0x6a, 0x40, 0x39, 0x21, 0xe0, 0x41, 0x13, 0x37, 0x31,
	0xaa, 0xcc, 0xc8, 0xec, 0x8a, 0xdb, 0x49, 0x7b, 0x68, 0x3f, 0xc9, 0x58, 0x60, 0xd2, 0x4e, 0x2c,
	0x64, 0x51, 0x85, 0x6a, 0xe1, 0xa5, 0xed, 0xfb, 0xb4, 0x27, 0xcc, 0x56, 0x63, 0xb2, 0x13, 0x2e,
	0x62, 0x76, 0x45, 0x95, 0xc8, 0x8b, 0x4c, 0x07, 0x29, 0xab, 0x64, 0xa8, 0x4c, 0x72, 0xca, 0x04,
	0x8c, 0x1a, 0x61, 0x77, 0xdf, 0xb4, 0x1d, 0xda, 0x43, 0x6a, 0x24, 0x19, 0x38, 0xe2, 0x05, 0x4a,
	0xc6, 0x0e, 0x54, 0x67, 0x38, 0x70, 0x1b, 0xea, 0xf8, 0x11, 0x9f, 0x1e, 0x26, 0x4f, 0x5f, 0x43,
	0x05, 0x71, 0xf8, 0xcf, 0x63, 0x44, 0xa9, 0x21, 0xa2, 0x2c, 0xc4, 0x76, 0xcf, 0xe0, 0xc9, 0x1a,
	0xcc, 0x07, 0xd4, 0x0c, 0x3d, 0xb7, 0x59, 0xe7, 0x4e, 0xe5, 0x2d, 0xfd, 0x9f, 0x6a, 0x50, 0xfd,
	0x10, 0xf7, 0x7d, 0x05, 0x6a, 0x14, 0x57, 0x0c, 0x99, 0x0c, 0x90, 0xd4, 0x11, 0xc6, 0x58, 0x21,
	0xe3, 0x6c, 0x69, 0xba, 0xb3, 0xbf, 0x04, 0xf0, 0xcd, 0x80, 0xba, 0x51, 0x97, 0xad, 0x3d, 0x9f,
	0x5b, 0x5b, 0xe5, 0x7d, 0x8c, 0x8e, 0xa7, 0xc2, 0xa6, 0xfa, 0xe1, 0x61, 0xf3, 0x1c, 0x94, 0xbe,
	0xed, 0xda, 0xe1, 0x85, 0xf0, 0xc9, 0xf4, 0x61, 0x89, 0xee, 0xe4, 0x1d, 0x54, 0x67, 0xdd, 0xc1,
	0xc4, 0x0d, 0x30, 0xc5, 0x0d, 0xdf, 0x83, 0xe6, 0x8f, 0x69, 0x4f, 0x17, 0x79, 0x6d, 0x1d, 0x67,
	0x5e, 0xe1, 0x06, 0xca, 0x72, 0x22, 0x63, 0xd1, 0xcf, 0x91, 0xa4, 0xc7, 0xa0, 0xc5, 0xa6, 0xeb,
	0x5e, 0xd1, 0x20, 0x64, 0xb4, 0x70, 0x01, 0xaf, 0xfc, 0x62, 0x2c, 0xff, 0x0d, 0x17, 0x93, 0x87,
	0xac, 0x92, 0xc3, 0x3a, 0xa5, 0xd9, 0xc0, 0x25, 0xea, 0xa2, 0x92, 0x43, 0x99, 0x11, 0x77, 0x32,
	0xae, 0x47, 0xb1, 0x14, 0x6a, 0x2e, 0xc6, 0x67, 0xf4, 0xc3, 0x6d, 0x5e, 0x1d, 0x19, 0xa2, 0x8b,
	0x15, 0x31, 0xc2, 0x1e, 0x82, 0x0a, 0x2f, 0xe1, 0x35, 0x12, 0x26, 0xd8, 0xe3, 0x84, 0xf8, 0x09,
	0xd4, 0x84, 0x12, 0x92, 0x7b, 0x92, 0x62, 0x23, 0x06, 0xf5, 0x3d, 0x03, 0x78, 0x2f, 0xfb, 0x4e,
	0x87, 0xec, 0xca, 0xac, 0x90, 0x5d, 0x2b, 0x0a, 0xd9, 0x6c, 0x3c, 0xae, 0xe7, 0xe3, 0xf1, 0x39,
	0x2c, 0x88, 0xb4, 0x1e, 0x62, 0x9e, 0x6f, 0x36, 0x31, 0x25, 0xf3, 0xb0, 0x4b, 0x03, 0x80, 0x51,
	0x7f, 0x93, 0x86, 0x83, 0xef, 0x60, 0x29, 0x10, 0xf9, 0xb1, 0x1b, 0xd0, 0xdf, 0x8e, 0x68, 0x18,
	0x85, 0xcd, 0x8d, 0x54, 0xc8, 0xa6, 0xb3, 0xa7, 0xa1, 0xc5, 0xba, 0x86, 0x50, 0x65, 0x0c, 0xd0,
	0x66, 0x09, 0xbf, 0xd9, 0x4a, 0x31, 0x40, 0x41, 0xd6, 0xb1, 0x83, 0x6c, 0x03, 0xb8, 0xf4, 0x4d,
	0x6c, 0xc7, 0x3b, 0xa8, 0xb6, 0x88, 0x46, 0xe2, 0x66, 0x44, 0x46, 0xa6, 0xba, 0xf4, 0x8d, 0xb0,
	0xea, 0x16, 0xd4, 0x6c, 0xd7, 0x0a, 0xe8, 0x90, 0xba, 0xec, 0xa4, 0x9f, 0x21, 0xb3, 0x4e, 0x8b,
	0x26, 0x32, 0xc6, 0xdd, 0x19, 0x19, 0x23, 0x9f, 0xed, 0xee, 0x4d, 0x66, 0xbb, 0x24, 0x5b, 0x6d,
	0xce, 0xc8, 0x56, 0xf7, 0xa1, 0x4e, 0x5d, 0xf3, 0xdc, 0xa1, 0x5d, 0xae, 0xbf, 0xc5, 0xb7, 0xc7,
	0x65, 0x9c, 0x75, 0xb0, 0x02, 0xce, 0x74, 0xa2, 0xe6, 0x7d, 0x51, 0xc0, 0x99, 0x4e, 0xc4, 0xd8,
	0xe5, 0xb9, 0x19, 0x59, 0x17, 0x4d, 0x9d, 0xd7, 0xfe, 0xd8, 0x48, 0x65, 0xa9, 0xcf, 0xd3, 0x59,
	0x8a, 0x7c, 0x03, 0x8b, 0x89, 0x53, 0x1c, 0x7b, 0x68, 0x47, 0x61, 0xf3, 0x8b, 0x9b, 0x5c, 0xd2,
	0x88, 0x35, 0x8f, 0x51, 0x91, 0xfc, 0x0c, 0xc0, 0xba, 0x18, 0xb9, 0x97, 0x3c, 0xd8, 0x1e, 0xa4,
	0x2b, 0x24, 0x26, 0xc6, 0x31, 0xaa, 0x15, 0x7f, 0x22, 0x81, 0x64, 0x6c, 0x1c, 0x99, 0x8b, 0x37,
	0x8a, 0x9a, 0x0f, 0x67, 0x13, 0x48, 0xa6, 0x7f, 0xca, 0xd5, 0x19, 0x05, 0x64, 0x1c, 0x21, 0x1e,
	0xfd, 0xe5, 0x4c, 0x0a, 0xf8, 0xda, 0x3b, 0x8f, 0xc7, 0xe6, 0x30, 0xe4, 0x51, 0x1e, 0x43, 0xda,
	0xb2, 0x22, 0x6b, 0x95, 0xb6, 0xac, 0x54, 0xb4, 0x79, 0xfd, 0x00, 0xe6, 0xf9, 0x35, 0x2e, 0x2c,
	0x67, 0x1f, 0x66, 0xcb, 0x0c, 0x2d, 0x77, 0xed, 0xe3, 0x84, 0xa4, 0x3f, 0x13, 0x45, 0x5f, 0xdf,
	0x0b, 0xc9, 0x97, 0xa0, 0x20, 0xbd, 0x71, 0xfb, 0x5e, 0xb3, 0x84, 0xd1, 0x52, 0x8f, 0x93, 0x18,
	0xde, 0xc9, 0xea, 0x6b, 0xfe, 0xa1, 0xdf, 0x03, 0x25, 0xce, 0xe4, 0x45, 0x8b, 0xeb, 0x7f, 0x5b,
	0x82, 0x85, 0x58, 0x81, 0xd7, 0x93, 0x77, 0x45, 0xbd, 0x5f, 0xca, 0xa7, 0x84, 0xfc, 0x7b, 0x45,
	0x39, 0x53, 0x61, 0xc7, 0x15, 0xa6, 0x54, 0x50, 0x61, 0xca, 0x05, 0x15, 0x66, 0x25, 0x65, 0x81,
	0x4d, 0x90, 0xfb, 0x81, 0x37, 0x14, 0x90, 0x92, 0x09, 0x06, 0xec, 0xd0, 0xff, 0xae, 0x0c, 0x1a,
	0x63, 0x2f, 0xe3, 0x9d, 0xf6, 0x3d, 0xf2, 0x28, 0xb6, 0x5b, 0x09, 0xed, 0x46, 0x32, 0xb0, 0x95,
	0x49, 0xe5, 0x5f, 0x41, 0x8d, 0xdd, 0xa8, 0x38, 0xe6, 0xca, 0x93, 0xcb, 0x00, 0xeb, 0x17, 0x21,
	0xb7, 0x0f, 0xcc, 0xd1, 0x5d, 0x2c, 0xa2, 0x42, 0x41, 0x0f, 0xbf, 0xe0, 0x89, 0x36, 0xb7, 0x05,
	0x66, 0xee, 0x7d, 0x54, 0xe3, 0xaf, 0x72, 0xea, 0xeb, 0xb8, 0x9d, 0x0a, 0x0f, 0x39, 0x13, 0x1e,
	0x77, 0x01, 0xcc, 0x51, 0x74, 0xd1, 0x8d, 0xbc, 0x4b, 0xea, 0x0a, 0x23, 0xa8, 0x4c, 0x72, 0xca,
	0x04, 0xad, 0x6f, 0xa1, 0x91, 0x9d, 0x33, 0xfd, 0x52, 0x56, 0x29, 0x78, 0x29, 0xab, 0xa4, 0x5f,
	0xca, 0x7e, 0x02, 0xa8, 0x67, 0x4c, 0x94, 0x06, 0xf7, 0xd2, 0x74, 0x70, 0xbf, 0x1d, 0x6b, 0xf8,
	0x3d, 0x00, 0x2b, 0xa0, 0x66, 0x44, 0x7b, 0x5d, 0x33, 0x12, 0x7e, 0x9b, 0x86, 0xd6, 0xaa, 0xd0,
	0xde, 0x8d, 0xc6, 0x6e, 0xab, 0xce, 0x72, 0xdb, 0x7d, 0xa8, 0x07, 0x94, 0x95, 0x8f, 0x5d, 0x1a,
	0x04, 0x5e, 0x80, 0xa4, 0x40, 0x35, 0x6a, 0x5c, 0x76, 0xc8, 0x44, 0xe4, 0xfb, 0x8c, 0xaf, 0x54,
	0xf4, 0xd5, 0x56, 0x66, 0xc6, 0x19, 0x7e, 0x2a, 0x42, 0x79, 0xb8, 0x0d, 0xca, 0x37, 0xa1, 0x1a,
	0x83, 0x7b, 0x8d, 0x83, 0xa3, 0x68, 0x7e, 0x24, 0x58, 0x6b, 0x05, 0x60, 0xcd, 0x1f, 0x3b, 0x96,
	0x26, 0x1e, 0x3b, 0x7e, 0x80, 0x95, 0xd0, 0x32, 0x1d, 0xda, 0x65, 0xa5, 0x56, 0x37, 0xba, 0x08,
	0x68, 0x78, 0xe1, 0x39, 0x3d, 0x81, 0xe6, 0x53, 0x32, 0x19, 0xc1, 0x61, 0x07, 0xde, 0x1b, 0xf7,
	0x34, 0x1e, 0x54, 0x8c, 0xa6, 0xcb, 0x1f, 0x81, 0xa6, 0x2b, 0x37, 0xa1, 0xe9, 0x16, 0xd4, 0x7a,
	0x34, 0xb4, 0x02, 0xdb, 0x67, 0x9b, 0x68, 0xae, 0x72, 0x77, 0xa6, 0x44, 0x79, 0xfc, 0x5c, 0x9b,
	0xc4, 0xcf, 0xbb, 0x00, 0x96, 0x69, 0x5d, 0x88, 0x92, 0x69, 0x9d, 0xc7, 0x0f, 0x4a, 0x58, 0xc9,
	0x34, 0x01, 0x71, 0xcd, 0x9b, 0x21, 0x6e, 0xa3, 0x08, 0xe2, 0xee, 0x14, 0x43, 0xdc, 0x67, 0x99,
	0x18, 0xfe, 0x02, 0x1a, 0x43, 0xf3, 0x6d, 0x37, 0x55, 0xba, 0xdd, 0xc5, 0xf4, 0x5f, 0x1f, 0x9a,
	0x6f, 0xff, 0x28, 0xae, 0xde, 0xd2, 0x9c, 0xee, 0xde, 0x34, 0x4e, 0x57, 0x00, 0x98, 0x9b, 0x1f,
	0x07, 0x98, 0x5b, 0xb7, 0x06, 0xcc, 0xfb, 0x9f, 0x04, 0x98, 0xfa, 0x6d, 0x00, 0xf3, 0x29, 0xd4,
	0x06, 0x76, 0x74, 0xe1, 0x79, 0x97, 0xdd, 0x51, 0xe0, 0x70, 0xd2, 0xb0, 0xd7, 0xb8, 0x7e, 0xbf,
	0x09, 0x2f, 0xb9, 0xf8, 0xcc, 0x38, 0x36, 0x40, 0xa8, 0x9c, 0x05, 0x4e, 0x3e, 0x69, 0x7f, 0x31,
	0x35, 0x69, 0x7f, 0x5a, 0xe2, 0x6c, 0xcb, 0x8a, 0xa4, 0xc9, 0x09, 0x64, 0xb7, 0xb4, 0x3b, 0xfa,
	0xcb, 0x34, 0x2c, 0x32, 0xc4, 0x7d, 0x0e, 0x0b, 0x09, 0x9b, 0x4f, 0xc1, 0xee, 0xd2, 0x44, 0xb2,
	0x31, 0xea, 0x7e, 0xaa, 0xa5, 0xff, 0x77, 0x09, 0xb4, 0x7d, 0x4c, 0x7e, 0xac, 0x48, 0xe2, 0xc1,
	0xf2, 0x49, 0x15, 0xf6, 0xc6, 0x8c, 0xea, 0x26, 0x77, 0x98, 0x92, 0x56, 0x6e, 0xcb, 0x0a, 0x68,
	0x35, 0xfe, 0xe0, 0xdf, 0x96, 0x15, 0x55, 0x83, 0xb6, 0xac, 0x28, 0x9a, 0xda, 0x96, 0x95, 0xba,
	0xb6, 0xd0, 0x96, 0x95, 0x9a, 0x56, 0x6f, 0xcb, 0xca, 0x82, 0xd6, 0x68, 0xcb, 0x4a, 0x43, 0x5b,
	0x6c, 0xcb, 0xca, 0xaa, 0xb6, 0xd6, 0x96, 0x95, 0x45, 0x4d, 0x6b, 0xcb, 0x8a, 0xa6, 0x2d, 0xb5,
	0x65, 0x65, 0x49, 0x23, 0x6d, 0x59, 0x21, 0xda, 0x72, 0x5b, 0x56, 0x96, 0xb5, 0x95, 0xb6, 0xac,
	0xac, 0x68, 0xab, 0x6d, 0x59, 0x59, 0xd3, 0xd6, 0xdb, 0xb2, 0xb2, 0xae, 0x35, 0xdb, 0xb2, 0xd2,
	0xd4, 0x36, 0xf4, 0x0e, 0x2c, 0x1d, 0xb9, 0xcc, 0x31, 0x51, 0xea, 0xbc, 0xd3, 0xca, 0xd5, 0x4d,
	0xa8, 0x9d, 0x3b, 0x9e, 0x75, 0xd9, 0x1d, 0x93, 0x20, 0xc5, 0x00, 0x14, 0x21, 0x1a, 0xe8, 0x7f,
	0x53, 0x82, 0xc6, 0xb1, 0x1d, 0x46, 0x37, 0xd8, 0x6f, 0x06, 0xae, 0x6d, 0x43, 0x1d, 0xb3, 0xcf,
	0x18, 0xfc, 0xa5, 0x09, 0xc2, 0x8d, 0x0a, 0x02, 0xfd, 0x6f, 0xfd, 0xa2, 0xa1, 0xbf, 0x86, 0xc5,
	0x17, 0xce, 0x28, 0xbc, 0x48, 0xed, 0xef, 0x01, 0x54, 0xf9, 0xe8, 0x50, 0x5c, 0x93, 0xcc, 0xf0,
	0xb8, 0x8f, 0x7c, 0x0d, 0xf5, 0xc8, 0xeb, 0xc6, 0x5b, 0x8d, 0x7f, 0x56, 0xc8, 0x1d, 0xa5, 0x16,
	0x79, 0xf1, 0x77, 0xa8, 0x6f, 0x83, 0x76, 0x40, 0x1d, 0x9a, 0xb9, 0x4c, 0x53, 0x8c, 0xab, 0x7f,
	0x05, 0x8d, 0x93, 0xc8, 0xf3, 0x3f, 0x50, 0xfb, 0xbf, 0x4a, 0xd0, 0x78, 0x49, 0xa3, 0x63, 0x6f,
	0x10, 0x7e, 0x88, 0xe7, 0x6e, 0x71, 0x8b, 0xe3, 0x32, 0xa6, 0x6f, 0x3b, 0x11, 0x0d, 0x38, 0xab,
	0x52, 0x79, 0x19, 0xf3, 0x82, 0x8b, 0xf0, 0x2d, 0xcb, 0x0c, 0x23, 0x1a, 0x20, 0x2b, 0x52, 0x0c,
	0xd1, 0x1a, 0xbf, 0xd3, 0xcf, 0xdf, 0xf4, 0x4e, 0xbf, 0x06, 0xf3, 0x7d, 0xcf, 0x71, 0xbc, 0x37,
	0xe2, 0xd7, 0x49, 0xd1, 0x62, 0x99, 0x3e, 0x32, 0x6d, 0x47, 0x3c, 0xf0, 0xe0, 0x37, 0x0f, 0x0b,
	0xfd, 0x9f, 0xcb, 0x00, 0xc7, 0xde, 0xe0, 0x0f, 0x69, 0x18, 0x9a, 0x03, 0xfc, 0x6d, 0x30, 0x89,
	0xed, 0x14, 0x43, 0x4e, 0x02, 0xf9, 0x15, 0x23, 0xa9, 0xe3, 0x17, 0x45, 0x69, 0xc6, 0x8b, 0xa2,
	0x3c, 0xe5, 0x45, 0xf1, 0x09, 0x94, 0x93, 0x87, 0xc1, 0x69, 0x84, 0xa9, 0x1c, 0x85, 0x8c, 0x5a,
	0x0c, 0xf9, 0x0e, 0xf1, 0xec, 0xaa, 0x11, 0x37, 0xb3, 0x0f, 0xa1, 0xd5, 0xa9, 0x0f, 0xa1, 0x04,
	0xe4, 0x51, 0x48, 0x03, 0xf1, 0x03, 0x20, 0x7e, 0x93, 0x87, 0xa0, 0x70, 0x1c, 0xb0, 0x7b, 0xf8,
	0x58, 0xa2, 0xee, 0xd5, 0xae, 0xdf, 0x6f, 0x56, 0xf9, 0x6f, 0x23, 0x07, 0x46, 0x15, 0x3b, 0x8f,
	0x7a, 0x29, 0x97, 0x40, 0xda, 0x25, 0xfa, 0x29, 0x2c, 0x1b, 0xfc, 0x05, 0x80, 0xfb, 0xe1, 0x03,
	0xee, 0x4a, 0xfe, 0x02, 0x94, 0x27, 0x2e, 0x80, 0xfe, 0xbb, 0xb0, 0x2c, 0x32, 0x47, 0x66, 0xd6,
	0x99, 0xbf, 0xd3, 0xe8, 0x5d, 0xd0, 0x58, 0x7e, 0xf8, 0xe0, 0xbd, 0xdc, 0x01, 0xd5, 0x37, 0x07,
	0x02, 0xba, 0xcb, 0x78, 0x39, 0x14, 0x26, 0x40, 0xd8, 0xc6, 0x5f, 0xa2, 0x06, 0x54, 0xbc, 0x9d,
	0xe2, 0xb7, 0xfe, 0x0e, 0x96, 0x52, 0x0b, 0x84, 0xbe, 0xe7, 0x86, 0xf8, 0x70, 0x2e, 0x8c, 0xc8,
	0xf0, 0x41, 0xc4, 0x79, 0x63, 0xbc, 0x3b, 0xc4, 0x02, 0xe8, 0xc5, 0x9f, 0x21, 0x4b, 0x74, 0xf8,
	0x00, 0xd2, 0x65, 0x73, 0x86, 0x62, 0x61, 0x40, 0x51, 0x87, 0x49, 0x0a, 0x97, 0xfe, 0x53, 0x58,
	0x4f, 0x96, 0x3e, 0x89, 0x02, 0x6a, 0x8e, 0x37, 0xf0, 0x33, 0x80, 0xf1, 0x06, 0x32, 0x3f, 0x0f,
	0x8c, 0xd7, 0x57, 0x93, 0xf5, 0x3f, 0x6e, 0xf9, 0x3d, 0x50, 0x13, 0x26, 0xc1, 0xae, 0x83, 0x3b,
	0x1a, 0x9e, 0xd3, 0x40, 0xfc, 0xce, 0x24, 0x5a, 0x8c, 0x93, 0x31, 0x53, 0x8a, 0x87, 0x7d, 0x3e,
	0xb1, 0xca, 0x24, 0xfc, 0x19, 0xff, 0xdf, 0xab, 0xb0, 0xca, 0x11, 0x30, 0x49, 0x0c, 0xb7, 0x4f,
	0xe3, 0xb7, 0x2b, 0x4f, 0xd6, 0x60, 0x7e, 0xe4, 0xf7, 0x18, 0x9c, 0x88, 0x5c, 0xc2, 0x5b, 0x85,
	0x6c, 0xbf, 0x7a, 0x1b, 0xb6, 0x3f, 0xe6, 0xf4, 0xea, 0x2d, 0x38, 0x3d, 0x14, 0x70, 0xfa, 0x9b,
	0xb8, 0x7b, 0xed, 0xff, 0x8d, 0xbb, 0xd7, 0x3f, 0x82, 0xbb, 0x2f, 0x7c, 0x20, 0x77, 0x6f, 0xcc,
	0xe4, 0xee, 0x8b, 0xb3, 0xb8, 0xbb, 0x36, 0x8b, 0xbb, 0x2f, 0x4d, 0x72, 0xf7, 0xcf, 0x40, 0x0d,
	0xa8, 0x78, 0x6c, 0xc4, 0x2a, 0x47, 0x31, 0xc6, 0x82, 0x31, 0x8b, 0x5f, 0x4e, 0xb3, 0xf8, 0x49,
	0xb6, 0xbe, 0x32, 0x9d, 0xad, 0xaf, 0xde, 0x92, 0xad, 0xaf, 0x7d, 0x1c, 0x5b, 0x5f, 0xbf, 0x35,
	0x5b, 0x6f, 0x7e, 0x12, 0x5b, 0xdf, 0xb8, 0x0d, 0x5b, 0x8f, 0x8b, 0xa4, 0xd6, 0xb8, 0x48, 0x4a,
	0xf3, 0x4a, 0x7d, 0x1f, 0xd6, 0x44, 0xae, 0xfe, 0xf8, 0x98, 0xd6, 0x57, 0x61, 0x99, 0xe5, 0xb6,
	0xdc, 0x0c, 0xfa, 0x9f, 0xc0, 0x2a, 0xe7, 0x38, 0x9f, 0x90, 0x2e, 0x34, 0x90, 0x4c, 0xc7, 0x11,
	0x0f, 0x4f, 0xec, 0xb3, 0x2d, 0x2b, 0x65, 0x4d, 0xe2, 0x67, 0xd0, 0x77, 0x61, 0xe5, 0x84, 0xa1,
	0xd7, 0x27, 0xec, 0xfd, 0x57, 0xb0, 0xcc, 0x88, 0xd5, 0x27, 0xcc, 0xf0, 0xe7, 0x25, 0x58, 0x31,
	0x68, 0x30, 0x72, 0x3f, 0xe1, 0x98, 0x0f, 0xa0, 0x4a, 0xdf, 0x5a, 0xce, 0xa8, 0x47, 0x8b, 0x78,
	0x6d, 0xdc, 0xc7, 0xd4, 0x6c, 0x97, 0xab, 0x49, 0x05, 0x6a, 0xa2, 0x4f, 0x5f, 0x87, 0xd5, 0x97,
	0x66, 0x70, 0x6e, 0x0e, 0xe8, 0xbe, 0xe7, 0x38, 0xd4, 0x8a, 0x62, 0x8f, 0x34, 0x61, 0x2d, 0xdf,
	0xc1, 0x31, 0x88, 0xb9, 0x70, 0xd7, 0x8a, 0xec, 0x2b, 0x33, 0xa2, 0xbb, 0xa3, 0xe8, 0x22, 0x1e,
	0xb0, 0x06, 0x2b, 0x59, 0x31, 0x57, 0x7f, 0xd2, 0xc5, 0x27, 0x4c, 0xfe, 0x5f, 0x0e, 0x1a, 0xd4,
	0xdb, 0xbf, 0xde, 0xeb, 0x9e, 0x9c, 0xee, 0x1a, 0xa7, 0x47, 0xaf, 0x5e, 0x6a, 0x73, 0x64, 0x11,
	0x6a, 0x4c, 0x62, 0x9c, 0xbd, 0x7a, 0xc5, 0x04, 0xa5, 0x58, 0xf0, 0x62, 0xf7, 0xe8, 0xf8, 0xcc,
	0x38, 0xd4, 0xca, 0xb1, 0xe0, 0xe4, 0x6c, 0x7f, 0xff, 0xf0, 0xe4, 0x44, 0x93, 0x48, 0x03, 0x80,
	0x09, 0x7e, 0x38, 0x3a, 0x3e, 0x3e, 0x3c, 0xd0, 0xe4, 0x27, 0xbf, 0x02, 0x18, 0xff, 0x83, 0x06,
	0x01, 0x98, 0x67, 0x63, 0x0f, 0x0f, 0xb4, 0x39, 0x52, 0x83, 0x6a, 0x3c, 0xac, 0x84, 0x8d, 0x1f,
	0x8e, 0x3a, 0x9d, 0xc3, 0x03, 0xad, 0x4c, 0xea, 0xa0, 0x24, 0x9b, 0x90, 0x9e, 0x7c, 0x0f, 0xb5,
	0xd4, 0xdb, 0x2b, 0x5b, 0xb1, 0xf3, 0xeb, 0x83, 0x64, 0x4f, 0x73, 0xb1, 0x60, 0x3c, 0x57, 0x03,
	0x80, 0x09, 0xc4, 0x42, 0xe5, 0x27, 0x7f, 0x96, 0x7a, 0x51, 0xe5, 0x73, 0xac, 0xc2, 0x52, 0xe7,
	0xa8, 0x73, 0x78, 0x7c, 0xf4, 0xea, 0x30, 0x7d, 0xdc, 0x15, 0xd0, 0x12, 0xf1, 0xf8, 0xcc, 0xeb,
	0xb0, 0x3c, 0x96, 0x1e, 0x26, 0xea, 0xe5, 0x8c, 0x7a, 0x6c, 0x11, 0x89, 0x2c, 0xc3, 0x62, 0x22,
	0xed, 0xec, 0x9e, 0x9d, 0x30, 0x2b, 0xec, 0xfc, 0x0f, 0x80, 0xb4, 0xdb, 0x39, 0x22, 0xdb, 0xa0,
	0x26, 0xa5, 0x27, 0x59, 0x15, 0xff, 0x6a, 0x94, 0x2d, 0x45, 0x5b, 0x09, 0x37, 0xd2, 0xe7, 0xc8,
	0x2f, 0x00, 0xc6, 0xb5, 0x1b, 0x59, 0x13, 0x28, 0x90, 0x2b, 0xe6, 0x5a, 0x99, 0x97, 0x66, 0x7d,
	0x8e, 0x3c, 0x85, 0xaa, 0x28, 0xcf, 0xc8, 0x32, 0x76, 0x65, 0x8b, 0xb5, 0xd6, 0x42, 0x5a, 0x3f,
	0xd4, 0xe7, 0x58, 0x29, 0x2d, 0x54, 0x38, 0xa3, 0x29, 0x1e, 0x96, 0x5b, 0xe6, 0xeb, 0x12, 0xd9,
	0x01, 0x25, 0x2e, 0xb4, 0x08, 0xc7, 0xeb, 0x5c, 0xdd, 0x55, 0x30, 0xe6, 0x5b, 0x50, 0x93, 0x82,
	0x49, 0x98, 0x20, 0x5f, 0x40, 0xb5, 0xd6, 0x26, 0x72, 0xe2, 0xe1, 0xd0, 0x8f, 0xde, 0xe9, 0x73,
	0xe4, 0x97, 0x50, 0x15, 0xe5, 0x93, 0xd8, 0x63, 0xb6, 0x98, 0x9a, 0x32, 0xf2, 0x1b, 0xa8, 0xa7,
	0xc9, 0x2c, 0x69, 0xa6, 0x8d, 0x99, 0x66, 0xaa, 0xad, 0x1c, 0x65, 0xd3, 0xe7, 0xd8, 0x9e, 0x13,
	0xce, 0x27, 0xf6, 0x9c, 0xe7, 0xb7, 0xad, 0xb5, 0xbc, 0x58, 0x04, 0xe4, 0x1c, 0x69, 0xc3, 0x62,
	0x8e, 0x31, 0xde, 0x34, 0xc7, 0x67, 0x59, 0x71, 0x96, 0x5e, 0xa2, 0xf5, 0xf6, 0xf0, 0x3f, 0x10,
	0x12, 0xa2, 0x2f, 0x4e, 0x51, 0xc0, 0xfd, 0xa7, 0x58, 0xe2, 0x05, 0x34, 0xb2, 0xec, 0x8f, 0xb4,
	0x52, 0x37, 0x31, 0x97, 0xfc, 0xa6, 0xcc, 0xb3, 0x0f, 0x8b, 0x39, 0xc8, 0x21, 0x77, 0xd2, 0x46,
	0xcd, 0xcf, 0x34, 0xf9, 0x32, 0xa3, 0xcf, 0x91, 0xef, 0xa0, 0x9e, 0x86, 0x1c, 0x71, 0xa0, 0x02,
	0x14, 0x6a, 0x91, 0x89, 0xe1, 0x21, 0x3f, 0x4c, 0x16, 0x9b, 0xc4, 0x61, 0x0a, 0x01, 0x6b, 0xca,
	0x61, 0x0e, 0x60, 0x21, 0x83, 0x40, 0x64, 0x43, 0x5c, 0xaf, 0x49, 0x54, 0x9a, 0x32, 0xcb, 0x1e,
	0xd4, 0xd3, 0x20, 0x24, 0x4e, 0x53, 0x80, 0x4b, 0xd3, 0x77, 0x92, 0x41, 0x21, 0xb1, 0x93, 0x22,
	0x64, 0x9a, 0x32, 0xcb, 0x1f, 0xc4, 0x61, 0xb6, 0xeb, 0x38, 0xe4, 0x06, 0xb5, 0x29, 0xc3, 0x9f,
	0x41, 0x55, 0xbc, 0x3b, 0x88, 0x38, 0xcb, 0xbe, 0x42, 0xb4, 0xf8, 0xbf, 0xde, 0x8d, 0x2b, 0x76,
	0xbc, 0x9c, 0x3f, 0x40, 0x23, 0x8b, 0x4a, 0xc2, 0x17, 0x85, 0x18, 0xd6, 0xba, 0x53, 0xd8, 0x97,
	0x44, 0xcd, 0x21, 0xd4, 0xd3, 0x88, 0x25, 0x4c, 0x59, 0x80, 0x6d, 0xad, 0x8d, 0x82, 0x9e, 0x78,
	0x9a, 0x3d, 0xed, 0xa7, 0xeb, 0x7b, 0xa5, 0x7f, 0xbb, 0xbe, 0x57, 0xfa, 0x8f, 0xeb, 0x7b, 0xa5,
	0xbf, 0xfa, 0xcf, 0x7b, 0x73, 0xe7, 0xf3, 0x78, 0xd8, 0x67, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff,
	0x15, 0xbe, 0x08, 0x96, 0x1b, 0x2f, 0x00, 0x00,
}
